<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>sniper.io</title>
  <style>
  html, body {
    width: 100%;
    height: 100%;
  }
  body {
    background-color: #ffffff;
    margin: 0;
    overflow: hidden;
    font-family: arial;
  }
  #blocker {
    position: absolute;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.5);
  }
  #instructions {
    width: 100%;
    height: 100%;
    display: -webkit-box;
    display: -moz-box;
    display: box;
    -webkit-box-orient: horizontal;
    -moz-box-orient: horizontal;
    box-orient: horizontal;
    -webkit-box-pack: center;
    -moz-box-pack: center;
    box-pack: center;
    -webkit-box-align: center;
    -moz-box-align: center;
    box-align: center;
    color: #ffffff;
    text-align: center;
    cursor: pointer;
  }

  #canvasContainer {
    z-index: -10
  }
  </style>
</head>
<body>
  <!-- <script src="libraries/socket.io.js"></script> -->
  <script src="http://sniper.satvik.co:8000/socket.io/socket.io.js"></script>
  <script src="http://sniper.satvik.co/libraries/three.min.js"></script>
  <script src="http://sniper.satvik.co/libraries/cannon.min.js"></script>

  <!-- <script src="libraries/three.min.js"></script>
  <script src="libraries/cannon.min.js"></script> -->
  <script src="http://sniper.satvik.co/debug/Stats.js"></script>
  <script src="http://sniper.satvik.co/debug/CannonDebugRenderer.js"></script>
  <script src="http://sniper.satvik.co/js/pointerlockcontrols.js"></script>
  <script src="http://sniper.satvik.co/js/stage.js"></script>
  <script src="http://sniper.satvik.co/remotePlayer.js"></script>
  <!-- <script src="libraries/require.js"></script> -->

  <div id="blocker">
    <div id="instructions">
      <span style="font-size:40px">SNIPER.IO</span>
      <br />
      (W,A,S,D : Move, SPACE : Jump, MOUSE : Look, CLICK : Shoot, L-Shift : Scope)
    </div>
  </div>

  <!-- <div id="container">
  <div id="threeContainer"></div>
</div> -->
<!-- <div id="container">
<canvas id="canvas" style="width:100%;height:95%;border:1px gray solid;"></canvas>
</div> -->

<script>
var sphereShape, sphereBody, world, physicsMaterial, walls=[], balls=[], ballMeshes=[], boxes=[], boxMeshes=[];
var cannonDebugRenderer;
var camera, scene, renderer;
var geometry, material, mesh;
var width, height;
var controls,time = Date.now();
var blocker = document.getElementById( 'blocker' );
var instructions = document.getElementById( 'instructions' );
var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;


var socket;
var remotePlayers;

var dt = 1/60;

var stats = new Stats();


// document.getElementById("container").style.display = 'none';
var container;
var canvas;// = document.getElementById('canvas');
var overlay = null;
var scopingOverlay = null, scopingContext;

var weapon = new Bitmap('assets/GunSmall.png', 16, 10);


if ( havePointerLock ) {
  var element = document.body;
  var pointerlockchange = function ( event ) {
    if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
      controls.enabled = true;
      blocker.style.display = 'none';
    } else {
      controls.enabled = false;
      blocker.style.display = '-webkit-box';
      blocker.style.display = '-moz-box';
      blocker.style.display = 'box';
      instructions.style.display = '';
    }
  }
  var pointerlockerror = function ( event ) {
    instructions.style.display = '';
  }
  // Hook pointer lock state change events
  document.addEventListener( 'pointerlockchange', pointerlockchange, false );
  document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
  document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );
  document.addEventListener( 'pointerlockerror', pointerlockerror, false );
  document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
  document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );
  instructions.addEventListener( 'click', function ( event ) {
    instructions.style.display = 'none';
    // Ask the browser to lock the pointer
    element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
    if ( /Firefox/i.test( navigator.userAgent ) ) {
      var fullscreenchange = function ( event ) {
        if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {
          document.removeEventListener( 'fullscreenchange', fullscreenchange );
          document.removeEventListener( 'mozfullscreenchange', fullscreenchange );
          element.requestPointerLock();
        }
      }
      document.addEventListener( 'fullscreenchange', fullscreenchange, false );
      document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );
      element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;
      element.requestFullscreen();


    } else {
      element.requestPointerLock();
    }
    console.log("unhide")
    document.getElementById("container").style.display = '';
  }, false );
} else {
  instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
}
initCannon();
init();
animate();
function initCannon(){
  // Setup our world
  world = new CANNON.World();
  world.quatNormalizeSkip = 0;
  world.quatNormalizeFast = false;
  var solver = new CANNON.GSSolver();
  world.defaultContactMaterial.contactEquationStiffness = 1e9;
  world.defaultContactMaterial.contactEquationRelaxation = 4;
  solver.iterations = 7;
  solver.tolerance = 0.1;
  var split = true;
  if(split)
  world.solver = new CANNON.SplitSolver(solver);
  else
  world.solver = solver;
  world.gravity.set(0,-20,0);
  world.broadphase = new CANNON.NaiveBroadphase();
  // Create a slippery material (friction coefficient = 0.0)
  physicsMaterial = new CANNON.Material("slipperyMaterial");
  var physicsContactMaterial = new CANNON.ContactMaterial(physicsMaterial, physicsMaterial, 0.0, 0.3);
  // We must add the contact materials to the world
  world.addContactMaterial(physicsContactMaterial);

  // Create a sphere
  var mass = 50, radius = 0.8, playerHeight = 2;
  var size = new CANNON.Vec3(radius, radius, radius)
  sphereShape = new CANNON.Sphere(radius)//new CANNON.Box(size)
  sphereBody = new CANNON.Body({ mass: mass });
  sphereBody.addShape(sphereShape);
  sphereBody.position.set(0,2,-10);
  sphereBody.linearDamping = 0.9;
  // sphereBody.inertia.set(0, 0, 0);
  // sphereBody.invInertia.set(0, 0, 0);

  sphereBody.angularDamping = 0.5
  // sphereBody.fixedRotation = true
  sphereBody.updateMassProperties();
  world.addBody(sphereBody);
  // Create a plane
  var groundShape = new CANNON.Plane(); //inf size
  var groundBody = new CANNON.Body({ mass: 0 });
  groundBody.addShape(groundShape);
  groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
  world.addBody(groundBody);
}

function Bitmap(src, width, height) {
  this.image = new Image();
  this.image.src = src;
  this.width = width;
  this.height = height;
}

function init() {
  container = document.createElement('div')
  container.id = "container"
  document.body.appendChild(container);

  canvas = document.createElement('canvas')
  canvas.id = "canvas"
  container.appendChild(canvas)

  if(!overlay){
    overlay = createOverlay(canvas)
  }


  stats.showPanel( 0 ); // 0: fps, 1: ms, 2: mb, 3+: custom
  document.body.appendChild( stats.dom );


  camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x00bfff)
  // scene.fog = new THREE.Fog( 0x000000, 0, 500 );
  var ambient = new THREE.AmbientLight( 0x404040, 0.5 );
  scene.add( ambient );
  // light = new THREE.DirectionalLight( 0xffffff, 1 );
  // light.position.set( 10, 30, 20 );
  // light.target.position.set( 0, 0, 0 );
  // if(true){
  //   light.castShadow = true;
  //   light.shadowCameraNear = 20;
  //   light.shadowCameraFar = 50;//camera.far;
  //   light.shadowCameraFov = 40;
  //   // light.shadowMapBias = 0.1;
  //   // light.shadowMapDarkness = 0.7;
  //   // light.shadowMapWidth = 2*512;
  //   // light.shadowMapHeight = 2*512;
  //   //light.shadowCameraVisible = true;
  // }
  // scene.add( light );
  //
  // var oppLight = new THREE.DirectionalLight( 0xffffff, 1 );
  // oppLight.position.set( -10, 30, -20 );
  // oppLight.target.position.set( 0, 0, 0 );
  // if(true){
  //   oppLight.castShadow = false;
  //   oppLight.shadowCameraNear = 20;
  //   oppLight.shadowCameraFar = 50;//camera.far;
  //   oppLight.shadowCameraFov = 40;
  //   // light.shadowMapBias = 0.1;
  //   // light.shadowMapDarkness = 0.7;
  //   // light.shadowMapWidth = 2*512;
  //   // light.shadowMapHeight = 2*512;
  //   //light.shadowCameraVisible = true;
  // }
  // scene.add( oppLight );

  var hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
  hemiLight.color.setHSL( 0.6, 1, 0.6 );
  hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
  hemiLight.position.set( 0, 500, 0 );
  scene.add( hemiLight );

  var dirLight = new THREE.DirectionalLight( 0xffffff, 0.8 );
  dirLight.position.set( -135, 146, 50 );
  // dirLight.position.multiplyScalar( 50);
  dirLight.name = "dirlight";
  dirLight.target.position.set(0, 0, 0)
  dirLight.shadowCameraVisible = true;

  var d = 200;
  dirLight.shadowCameraLeft = -d;
  dirLight.shadowCameraRight = d;
  dirLight.shadowCameraTop = d;
  dirLight.shadowCameraBottom = -d;
  scene.add( dirLight );

  dirLight.castShadow = true;
  dirLight.shadowMapWidth = dirLight.shadowMapHeight = 1024*2;
  dirLight.shadowBias = -0.0007;
  dirLight.shadowDarkness = 0;

  var helper = new THREE.DirectionalLightHelper( dirLight );
  scene.add(helper);

  controls = new PointerLockControls( camera , sphereBody );
  controls.oldPos = new THREE.Vector3().copy(controls.getObject().position)
  scene.add( controls.getObject() );


  // floor
  geometry = new THREE.PlaneGeometry( 300, 300, 50, 50 );
  geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );
  material = new THREE.MeshLambertMaterial( { color: 0xffffff } );
  mesh = new THREE.Mesh( geometry, material );
  // mesh.castShadow = true;
  mesh.receiveShadow = true;
  scene.add( mesh );


  renderer = new THREE.WebGLRenderer({canvas: canvas});
  renderer.shadowMapEnabled = true;
  renderer.shadowMapSoft = true;

  // renderer.shadowCameraFar = camera.far;
  // renderer.shadowCameraFov = 75;
  // renderer.shadowCameraNear = 0.1;

  renderer.setSize( window.innerWidth, window.innerHeight );
  makeStage()

  var axisHelper = new THREE.AxisHelper( 5 );
  scene.add( axisHelper );



  // renderer.setClearColor( scene.fog.color, 1 );
  // document.getElementById("threeContainer").appendChild( renderer.domElement );
  window.addEventListener( 'resize', onWindowResize, false );

  cannonDebugRenderer = new THREE.CannonDebugRenderer(scene, world);

  remotePlayers = [];

  socket = io.connect("http://sniper.satvik.co")//("http://localhost", {port: 8000, transports: ["websocket"]});
  setSocketEventHandlers()

}

function setSocketEventHandlers(){
  socket.on("connect", onSocketConnected);
  socket.on("disconnect", onSocketDisconnect);
  socket.on("new player", onNewPlayer);
  socket.on("move player", onMovePlayer);
  socket.on("remove player", onRemovePlayer);
}

function makeStage(){
  var stage = createStage()
  var meshes = stage[0]
  var bodies = stage[1]

  var numMeshes = meshes.length
  var numBodies = bodies.length

  // if(numMeshes == numBodies){
    console.log("matches")
    for(var i = 0; i < numMeshes; i++){
      var mesh = meshes[i]
      var body = bodies[i]

      // var box = new THREE.BoxHelper( mesh, 0xffff00 );
      // scene.add( box );

      // Because the stage is static we don't add them to a array for updating
      if(mesh) scene.add(mesh)
      if(body) world.addBody(body)
    }
  // }
  console.log("made stage")
}


function createOverlay(mainCanvas){
  var canvasContainer = document.getElementById('container');
  var overlayCanvas = document.createElement('canvas');
  overlayCanvas.style.zIndex="1000";
  overlayCanvas.style.position = 'absolute';
  overlayCanvas.style.left = '0px';
  overlayCanvas.style.top = '0px';
  overlayCanvas.id = "overlay"
  overlayCanvas.width = mainCanvas.width;
  overlayCanvas.height = mainCanvas.height;

  var weaponCanvas = document.createElement('canvas')
  weaponCanvas.id = "weaponCanvas"
  // weaponCanvas.width = window.innerWidth
  // weaponCanvas.height = window.innerHeight
  weaponCanvas.style.zIndex = "1001"
  weaponCanvas.style.position = 'absolute';
  weaponCanvas.style.right = '0px';
  weaponCanvas.style.bottom = '0px';
  weaponCanvas.getContext('2d').imageSmoothingEnabled = false
  weaponCanvas.getContext('2d').transform(0.65,0.5,0,1,85,0);

  //scoping overlay
  scopingOverlay = document.createElement('canvas')
  scopingOverlay.style.zIndex="1002";//above weapon
  scopingOverlay.style.position = 'absolute';
  scopingOverlay.style.left = '0px';
  scopingOverlay.style.top = '0px';
  scopingOverlay.id = "scopingOverlay"
  scopingOverlay.width = window.innerWidth;
  scopingOverlay.height = window.innerHeight;
  scopingOverlay.style.display = 'none';

  scopingContext = scopingOverlay.getContext('2d')


  canvasContainer.appendChild(weaponCanvas)
  canvasContainer.appendChild(overlayCanvas);
  canvasContainer.appendChild(scopingOverlay);
  return overlayCanvas;
}

function drawOverlay() {
  var context = overlay.getContext('2d');
  context.clearRect(0, 0, overlay.width, overlay.height);
  var x = 10;
  var y = 40;
  context.font = "20pt Calibri";
  context.fillStyle = "#0000ff"; // text color
  context.fillText("sniper.io ", x, y);

  var weaponCanvas = document.getElementById('weaponCanvas')
  var weaponContext = weaponCanvas.getContext('2d')

  weaponContext.clearRect(0, 0, weaponCanvas.width, weaponCanvas.height);
  var scale = new THREE.Vector2(weaponCanvas.width/weapon.width, weaponCanvas.height/weapon.height)
  var left = overlay.width * 0.66;
  var top = overlay.height * 0.6;
  weaponContext.drawImage(weapon.image, 0, 0, weapon.width*scale.x, weapon.height * scale.y);

  scopingContext.save()
  scopingContext.fillStyle = 'rgba(0, 0, 0, 1)';
  scopingContext.fillRect(0, 0, window.innerWidth, window.innerHeight)

  // Set global composite operation to destination-out
  scopingContext.globalCompositeOperation = 'destination-out';

  // Draw circle
  scopingContext.strokeStyle = "#FFFFFF";
  scopingContext.beginPath();
  scopingContext.arc(window.innerWidth/2, window.innerHeight/2, ((window.innerWidth)/(window.innerHeight))*75, 0, Math.PI*2, false);
  scopingContext.fill();

  context.restore();
  weaponContext.restore();
  scopingContext.restore();
}

function onWindowResize() {
  // scopingOverlay.width = window.innerWidth;
  // scopingOverlay.height = window.innerHeight;

  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize( window.innerWidth, window.innerHeight );


}

function onSocketConnected() {
    console.log("Connected to socket server "+socket.id);
    var pos = controls.getPos()
    // controls.id =
    socket.emit("new player", {x: pos.x, y: pos.y, z: pos.z});
};

function onSocketDisconnect() {
    console.log("Disconnected from socket server");
};

function onNewPlayer(data) {
    console.log("New player connected: "+data.id);
    // var newPlayer = new Player(data.x, data.y);
    // newPlayer.id = data.id;
    // remotePlayers.push(newPlayer);

    var mass = 50, radius = 0.8, playerHeight = 2;

    var size = new CANNON.Vec3(radius, radius, radius)
    var bodyShape = new CANNON.Sphere(radius)//new CANNON.Box(size)
    var body = new CANNON.Body({ mass: mass });
    body.linearDamping = 0.9;
    // sphereBody.inertia.set(0, 0, 0);
    // sphereBody.invInertia.set(0, 0, 0);

    sphereBody.angularDamping = 0.5
    // sphereBody.fixedRotation = true
    sphereBody.updateMassProperties();



    var shape = new THREE.SphereGeometry(bodyShape.radius, 32, 32);
    var mesh = new THREE.Mesh( ballGeometry, material );


    var newPlayer = new RemotePlayer(body, mesh)
    newPlayer.id = data.id
    newPlayer.setPos(new CANNON.Vec3(data.x, data.y, data.z))

    newPlayer.getBody().addShape(bodyShape);
    world.addBody(newPlayer.getBody());
    scene.add(newPlayer.getMesh())
    remotePlayers.push(newPlayer)


};

function onMovePlayer(data) {
  var movePlayer = playerById(data.id);

  if (!movePlayer) {
      console.log("Player not found: "+data.id);
      return;
  };
  // console.log("Moving player "+data.id)
  movePlayer.setPos(new CANNON.Vec3(data.x, data.y, data.z))
};

function onRemovePlayer(data) {
  var removePlayer = playerById(data.id);

  if (!removePlayer) {
      console.log("Player not found: "+data.id);
      return;
  };

  scene.remove(removePlayer.getMesh())
  world.remove(removePlayer.getBody())

  remotePlayers.splice(remotePlayers.indexOf(removePlayer), 1);
};


function playerById(id) {
    var i;
    for (i = 0; i < remotePlayers.length; i++) {
        if (remotePlayers[i].id == id)
            return remotePlayers[i];
    };

    return false;
};

function animate() {

  stats.begin()

  if(controls.enabled){
    world.step(dt);
    // Update ball positions
    for(var i=0; i<balls.length; i++){
      ballMeshes[i].position.copy(balls[i].position);
      ballMeshes[i].quaternion.copy(balls[i].quaternion);
    }

    // sphereBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0), 0);
    // sphereBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0,0,1), 0);

    // Update box positions
    // for(var i=0; i<boxes.length; i++){
    //   boxMeshes[i].position.copy(boxes[i].position);
    //   boxMeshes[i].quaternion.copy(boxes[i].quaternion);
    // }
  }



  controls.update( Date.now() - time );
  if (controls.updateTestPos() == true) {
    var pos = controls.getObject().position
    // console.log("update move")
    socket.emit("move player", {id: socket.id, x: pos.x, y: pos.y, z: pos.z});
  };
  // console.log("Old: "+conrols.oldPos.x+" New: "+controls.getObject().position.x)

  // cannonDebugRenderer.update()
  renderer.render( scene, camera );
  drawOverlay()

  stats.end()

  time = Date.now();

  requestAnimationFrame( animate );
}

var ballShape = new CANNON.Sphere(0.2);
var ballGeometry = new THREE.SphereGeometry(ballShape.radius, 32, 32);
var shootDirection = new THREE.Vector3();
var shootVelo = 15;
var projector = new THREE.Projector();

// TODO: remove and replace with shooting detection of other players

function getShootDir(targetVec){
  var vector = targetVec;
  targetVec.set(0,0,1);
  vector.unproject(camera);
  // projector.unprojectVector(vector, camera);
  var ray = new THREE.Ray(sphereBody.position, vector.sub(sphereBody.position).normalize() );
  targetVec.copy(ray.direction);
}

window.addEventListener("click",function(e){
  if(controls.enabled==true){
    // var x = sphereBody.position.x;
    // var y = sphereBody.position.y;
    // var z = sphereBody.position.z;
    // var ballBody = new CANNON.Body({ mass: 1 });
    // ballBody.addShape(ballShape);
    // var ballMesh = new THREE.Mesh( ballGeometry, material );
    // world.addBody(ballBody);
    // scene.add(ballMesh);
    // ballMesh.castShadow = true;
    // ballMesh.receiveShadow = true;
    // balls.push(ballBody);
    // ballMeshes.push(ballMesh);
    // getShootDir(shootDirection);
    // ballBody.velocity.set(  shootDirection.x * shootVelo, shootDirection.y * shootVelo, shootDirection.z * shootVelo);
    // // Move the ball outside the player sphere
    // x += shootDirection.x * (sphereShape.radius*1.02 + ballShape.radius);
    // y += shootDirection.y * (sphereShape.radius*1.02 + ballShape.radius);
    // z += shootDirection.z * (sphereShape.radius*1.02 + ballShape.radius);
    // ballBody.position.set(x,y,z);
    // ballMesh.position.set(x,y,z);
  }
});

</script>
</body>
</html>
