<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>sniper.io</title>
  <style>
  html, body {
    width: 100%;
    height: 100%;
  }
  body {
    background-color: #ffffff;
    margin: 0;
    overflow: hidden;
    font-family: arial;
  }
  #blocker {
    position: absolute;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.5);
  }
  #instructions {
    width: 100%;
    height: 100%;
    display: -webkit-box;
    display: -moz-box;
    display: box;
    -webkit-box-orient: horizontal;
    -moz-box-orient: horizontal;
    box-orient: horizontal;
    -webkit-box-pack: center;
    -moz-box-pack: center;
    box-pack: center;
    -webkit-box-align: center;
    -moz-box-align: center;
    box-align: center;
    color: #ffffff;
    text-align: center;
    cursor: pointer;
  }

  #canvasContainer {
    z-index: -10
  }
  </style>
</head>
<body>
  <script src="http://sniper.satvik.co/socket.io/socket.io.js"></script>
  <script src="http://sniper.satvik.co/libraries/three.min.js"></script>
  <script src="http://sniper.satvik.co/libraries/cannon.min.js"></script>

  <script src="http://sniper.satvik.co/debug/Stats.js"></script>
  <script src="http://sniper.satvik.co/debug/CannonDebugRenderer.js"></script>
  <script src="http://sniper.satvik.co/js/pointerlockcontrols.js"></script>
  <script src="http://sniper.satvik.co/js/stage.js"></script>
  <script src="http://sniper.satvik.co/remotePlayer.js"></script>

  <div id="blocker" style="z-index: 3000;">
    <div id="instructions">
      <span style="font-size:40px; ">SNIPER.IO</span>
      <br />
      (W,A,S,D : Move, SPACE : Jump, MOUSE : Look, CLICK : Shoot, L-Shift : Scope)
    </div>
  </div>
<script>
var sphereShape, sphereBody, world, physicsMaterial;
var cannonDebugRenderer;
var camera, scene, renderer, raycaster;
var geometry, material, mesh;
var width, height;
var controls,time = Date.now();
var blocker = document.getElementById( 'blocker' );
var instructions = document.getElementById( 'instructions' );
var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

var socket;
var remotePlayers;
var localPlayer;

var dt = 1/60;

var stats = new Stats();

var container;
var canvas;
var overlay = null;
var scopingOverlay = null, scopingContext;
var crosshairOverlay = null, crosshairContext;

var weapon = new Bitmap('assets/GunSmall.png', 16, 10);

if ( havePointerLock ) {
  var element = document.body;
  var pointerlockchange = function ( event ) {
    if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
      controls.enabled = true;
      blocker.style.display = 'none';
      crosshairOverlay.style.display = '';
    } else {
      controls.enabled = false;
      blocker.style.display = '-webkit-box';
      blocker.style.display = '-moz-box';
      blocker.style.display = 'box';
      instructions.style.display = '';
    }
  }
  var pointerlockerror = function ( event ) {
    instructions.style.display = '';
    crosshairOverlay.style.display = 'none';
  }
  // Hook pointer lock state change events
  document.addEventListener( 'pointerlockchange', pointerlockchange, false );
  document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
  document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );
  document.addEventListener( 'pointerlockerror', pointerlockerror, false );
  document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
  document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );
  instructions.addEventListener( 'click', function ( event ) {
    instructions.style.display = 'none';
    crosshairOverlay.style.display = '';
    // Ask the browser to lock the pointer
    element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
    if ( /Firefox/i.test( navigator.userAgent ) ) {
      var fullscreenchange = function ( event ) {
        if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {
          document.removeEventListener( 'fullscreenchange', fullscreenchange );
          document.removeEventListener( 'mozfullscreenchange', fullscreenchange );
          element.requestPointerLock();
        }
      }
      document.addEventListener( 'fullscreenchange', fullscreenchange, false );
      document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );
      element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;
      element.requestFullscreen();
    } else {
      element.requestPointerLock();
    }
    // console.log("unhide")
    document.getElementById("container").style.display = '';
  }, false );
} else {
  instructions.innerHTML = 'Oh well, your browser doesn\'t seem to support SNIPER.IO';
}

// initCannon();
init();
animate();

function initMap(){
  cw.world = new CANNON.World();
  cw.world.quatNormalizeSkip = 0;
  cw.world.quatNormalizeFast = false;

  var solver = new CANNON.GSSolver();
  cw.world.defaultContactMaterial.contactEquationStiffness = 1e9;
  cw.world.defaultContactMaterial.contactEquationRelaxation = 4;
  solver.iterations = 7;
  solver.tolerance = 0.1;
  var split = true;
  if(split)
  cw.world.solver = new CANNON.SplitSolver(solver);
  else
  cw.world.solver = solver;
  cw.world.gravity.set(0,-20,0);
  cw.world.broadphase = new CANNON.NaiveBroadphase();
  // Create a slippery material (friction coefficient = 0.0)
  physicsMaterial = new CANNON.Material("slipperyMaterial");
  var physicsContactMaterial = new CANNON.ContactMaterial(physicsMaterial, physicsMaterial, 0.0, 0.3);
  // We must add the contact materials to the world
  cw.world.addContactMaterial(physicsContactMaterial);

  //Ground plane
  var groundShape = new CANNON.Plane(); //inf size
  var groundBody = new CANNON.Body({ mass: 0 });
  groundBody.addShape(groundShape);
  groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
  addPhysicsBody(groundBody);

  cannonDebugRenderer = new THREE.CannonDebugRenderer(scene, cw.world);

  createStage()
};

function addPhysicsBody(body){
  cw.world.addBody(body)
}

function updatePhysics(){
  cw.world.step(dt)
}

var cw = {} // Cannon World
var map = {}
var n;
var models = {}
var worldSize = 25 //HALF EXTENTS
var tileWidth;

function createStage(){
  var boundaryThickness = 1
  var boundaryHeight = 5
  var boundarySize = new CANNON.Vec3(worldSize*2/*-(boundaryThickness)*/, boundaryHeight, boundaryThickness)

  var boundaryMeshGeo = new THREE.Geometry()

  for(var i = 0; i < 4; i++){
    var halfExtents = new CANNON.Vec3(boundarySize.x/2, boundarySize.y/2, boundarySize.z/2)
    var boundarySideShape = new CANNON.Box(halfExtents)
    var boundarySideGeometry = new THREE.BoxGeometry(boundarySize.x, boundarySize.y, boundarySize.z);

    var rotation = (- Math.PI / 2)*i
    boundarySideGeometry.applyMatrix( new THREE.Matrix4().makeRotationY( rotation ) );

    var boundaryBody = new CANNON.Body({mass: 0})
    boundaryBody.addShape(boundarySideShape)
    boundaryBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0,1,0), rotation); //Match rotaion of geometry

    var boundaryMesh  = new THREE.Mesh(boundarySideGeometry, material)

    // var zSign =
    var zChange = 0
    var xChange = 0

    switch (i) {
      case 0:
      zChange = -worldSize
      xChange = 0
      break;
      case 1:
      zChange = 0
      xChange = -worldSize
      break;
      case 2:
      zChange = worldSize
      xChange = 0
      break;
      case 3:
      zChange = 0
      xChange = worldSize
      break;
      default:
      break;
    }

    boundaryBody.position.set(xChange, 0, zChange)
    boundaryMesh.position.set(xChange, 0, zChange)
    boundaryMesh.castShadow = false;

    boundaryMesh.updateMatrix()
    boundaryMeshGeo.merge(boundaryMesh.geometry, boundaryMesh.matrix)
    addPhysicsBody(boundaryBody)
  }
  scene.add(new THREE.Mesh(boundaryMeshGeo, material))

  loadModels()

  for(var i = 0; i < n*n; i++){
    //Create physics bodies
    if(map[i] > 0){
      createHouse(map[i]-1, i)
    }
  }

  console.log(n)
  //debug lines
  for(var x = 0; x < n; x++){
    var linePoints = new THREE.Geometry()
    linePoints.vertices.push(new THREE.Vector3(-worldSize, 0.1, (x-(n/2))*tileWidth))
    linePoints.vertices.push(new THREE.Vector3(worldSize, 0.1, (x-(n/2))*tileWidth))

    var mat;

    if(x == (n/2)){
      mat = new THREE.LineBasicMaterial({color: 0x0000ff})
    }else{
      mat = new THREE.LineBasicMaterial({color:0xff0000})
    }

    var mesh = new THREE.Line(linePoints, mat)
    scene.add(mesh)

  }

  for(var y = 0; y < n; y++){
    var linePoints = new THREE.Geometry()
    linePoints.vertices.push(new THREE.Vector3((y-(n/2))*tileWidth, 0.1, -worldSize))
    linePoints.vertices.push(new THREE.Vector3((y-(n/2))*tileWidth, 0.1, worldSize))

    var mat;

    if(y == (n/2)){
      mat = new THREE.LineBasicMaterial({color: 0x0000ff})
    }else{
      mat = new THREE.LineBasicMaterial({color:0xff0000})
    }

    var mesh = new THREE.Line(linePoints, mat)

    scene.add(mesh)
  }
}

function loadModels(){

  var numModels = 1
  for(var m = 0; m < numModels; m++){
    var request = new XMLHttpRequest();
    request.open('GET', '/assets/models/house'+m+'.json', false);  // `false` makes the request synchronous
    request.send(null);

    if (request.status === 200) {
      models[m] = request.responseText;
    }
  }
}

var houseMaterial = new THREE.MeshLambertMaterial( { color: 0xdddddd} ); //TODO MeshBasicMaterial?

function createHouse(num, gridTile){

  var response = models[num]
  // Parse JSON string into object
  var json = JSON.parse(response)
  var objs = json["objs"];
  var metadata = json["metadata"]
  var height = metadata[0]["totalHeight"]
  var width = metadata[0]["totalWidth"]

  // var newScale = tileWidth/width
  var gridPos = new CANNON.Vec3((gridTile%n-(n/2))*tileWidth, 0, (gridTile/n-(n/2))*tileWidth)


  function vectorFromJSON(jsonVector){
    return new CANNON.Vec3(jsonVector["x"], jsonVector["y"], jsonVector["z"])
  }

  function quatFromJSON(jsonVector){
    return new THREE.Quaternion(jsonVector["x"], jsonVector["y"], jsonVector["z"], jsonVector["w"])
  }

  function divideVector(vec, by){
    return new CANNON.Vec3(vec.x/by, vec.y/by, vec.z/by)
  }

  //  console.log("NS: "+newScale)
  var house = new THREE.Geometry()

  for(var i = 0; i < objs.length; i++){
    var obj = objs[i];
    var pos = divideVector(vectorFromJSON(obj["pos"]), 2)
    var scale = vectorFromJSON(obj["scale"])
    var rot = quatFromJSON(obj["rot"])

    // scale.x = scale.x*newScale
    // scale.y = scale.y*newScale
    // scale.z = scale.z*newScale
    //
    // pos.x = pos.x*newScale
    // pos.y = pos.y*newScale
    // pos.z = pos.z*newScale

    var halfExtents = new CANNON.Vec3(scale.x/2, scale.y/2, scale.z/2)
    var boxShape = new CANNON.Box(halfExtents)
    var boxGeometry = new THREE.BoxGeometry(scale.x, scale.y, scale.z);

    var boxBody = new CANNON.Body({mass: 0})
    boxBody.addShape(boxShape)

    boxBody.quaternion.set(rot.x, rot.y, rot.z, rot.w) //Match rotaion of geometry
    var boxMesh  = new THREE.Mesh(boxGeometry, houseMaterial)
    boxMesh.setRotationFromQuaternion(new THREE.Quaternion(rot.x, rot.y, rot.z, rot.w))

    // boxMesh.receiveShadow = true
    // boxMesh.castShadow = true
    // boxMesh.shadowBias = -0.0008

    var heightOffset = (height/2)//*newScale
    boxMesh.position.set(gridPos.x+pos.x, pos.y+heightOffset, gridPos.z+pos.z)
    boxBody.position.set(gridPos.x+pos.x, pos.y+heightOffset, gridPos.z+pos.z)
    // boxBody.position.set(gridPos.x+(pos.x/2), (pos.y/2)+height, gridPos.z+(pos.z/2))

    boxMesh.updateMatrix()
    house.merge(boxMesh.geometry, boxMesh.matrix)
    addPhysicsBody(boxBody)
  }
  var houseMesh = new THREE.Mesh(house, houseMaterial)
  // houseMesh.castShadow = true
  // houseMesh.receiveShadow = true
  // houseMesh.shadowBias = -0.008
  scene.add(houseMesh)
}

function Bitmap(src, width, height) {
  this.image = new Image();
  this.image.src = src;
  this.width = width;
  this.height = height;
}

function init() {
  container = document.createElement('div')
  container.id = "container"
  document.body.appendChild(container);

  canvas = document.createElement('canvas')
  canvas.id = "canvas"
  container.appendChild(canvas)

  if(!overlay){
    overlay = createOverlay(canvas)
  }

  stats.showPanel( 0 ); // 0: fps, 1: ms, 2: mb, 3+: custom
  document.body.appendChild( stats.dom );

  camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x00bfff)
  var ambient = new THREE.AmbientLight( 0x404040, 0.5 );
  scene.add( ambient );

  var hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
  hemiLight.color.setHSL( 0.6, 1, 0.6 );
  hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
  hemiLight.position.set( 0, 500, 0 );
  scene.add( hemiLight );

  var dirLight = new THREE.DirectionalLight( 0xffffff, 0.8 );
  dirLight.position.set( -135, 146, 50 );
  dirLight.name = "dirlight";
  dirLight.target.position.set(0, 0, 0)

  var shadowHelper = new THREE.CameraHelper( dirLight.shadow.camera );
  scene.add(shadowHelper);

  var d = 200;
  dirLight.shadow.camera.left = -d;
  dirLight.shadow.camera.right = d;
  dirLight.shadow.camera.top = d;
  dirLight.shadow.camera.bottom = -d;
  scene.add( dirLight );

  dirLight.castShadow = true;
  dirLight.shadow.mapSize.width = dirLight.shadow.mapSize.height = 1024*2;
  dirLight.shadow.bias = -0.0007;

  var helper = new THREE.DirectionalLightHelper( dirLight );
  scene.add(helper);

  // Create a sphere
  var mass = 50, radius = 0.8, playerHeight = 2;
  var size = new CANNON.Vec3(radius, radius, radius)
  sphereShape = new CANNON.Sphere(radius)//new CANNON.Box(size)
  sphereBody = new CANNON.Body({ mass: mass });
  sphereBody.addShape(sphereShape);
  sphereBody.position.set(0,2,-10);
  sphereBody.linearDamping = 0.9;

  localPlayer = new RemotePlayer(sphereBody, null)

  controls = new PointerLockControls( camera , sphereBody );
  controls.oldPos = new THREE.Vector3().copy(controls.getObject().position)
  scene.add( controls.getObject() );

  // floor
  geometry = new THREE.PlaneGeometry( 300, 300, 50, 50 );
  geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );
  material = new THREE.MeshLambertMaterial( { color: 0xffffff } );
  mesh = new THREE.Mesh( geometry, material );
  mesh.receiveShadow = true;
  scene.add( mesh );


  raycaster = new THREE.Raycaster()

  renderer = new THREE.WebGLRenderer({canvas: canvas});
  renderer.shadowMap.enabled = true;
  renderer.shadowMapSoft = true;

  renderer.setSize( window.innerWidth, window.innerHeight );

  var axisHelper = new THREE.AxisHelper( 5 );
  scene.add( axisHelper );

  window.addEventListener( 'resize', onWindowResize, false );

  remotePlayers = [];

  socket = io.connect("http://sniper.satvik.co")
  setSocketEventHandlers()

}

function setSocketEventHandlers(){
  socket.on("connect", onSocketConnected);
  socket.on("disconnect", onSocketDisconnect);
  socket.on("new player", onNewPlayer);
  // socket.on("move player", onMovePlayer);
  socket.on("hit player", onHitPlayer);
  socket.on("remove player", onRemovePlayer);
  socket.on("mapData", onMapData);
  socket.on("updatePlayers", onUpdatePlayers);
}

function onMapData(data){
  map = data.map
  n = data.n
  tileWidth = (worldSize*2)/n
  initMap()
}

function onUpdatePlayers(data){
  var playerData = data.data
  for(var p = 0; p < playerData.length; p++){
    var id = playerData[p].id
    var position = playerData[p].position

    var player = playerById(id)

    if(!player && id != socket.id){
      return
    }

    if(socket.id == id){
      localPlayer.setPos(position)
    }else{
      player.setPos(position)
    }
  }
}


function createOverlay(mainCanvas){
  var canvasContainer = document.getElementById('container');
  var overlayCanvas = document.createElement('canvas');
  overlayCanvas.style.zIndex="1000";
  overlayCanvas.style.position = 'absolute';
  overlayCanvas.style.left = '0px';
  overlayCanvas.style.top = '0px';
  overlayCanvas.id = "overlay"
  overlayCanvas.width = mainCanvas.width;
  overlayCanvas.height = mainCanvas.height;

  var weaponCanvas = document.createElement('canvas')
  weaponCanvas.id = "weaponCanvas"
  // weaponCanvas.width = window.innerWidth
  // weaponCanvas.height = window.innerHeight
  weaponCanvas.style.zIndex = "1001"
  weaponCanvas.style.position = 'absolute';
  weaponCanvas.style.right = '0px';
  weaponCanvas.style.bottom = '0px';
  weaponCanvas.getContext('2d').imageSmoothingEnabled = false
  weaponCanvas.getContext('2d').transform(0.65,0.5,0,1,85,0);

  //scoping overlay
  scopingOverlay = document.createElement('canvas')
  scopingOverlay.style.zIndex="1002";//above weapon
  scopingOverlay.style.position = 'absolute';
  scopingOverlay.style.left = '0px';
  scopingOverlay.style.top = '0px';
  scopingOverlay.id = "scopingOverlay"
  scopingOverlay.width = window.innerWidth;
  scopingOverlay.height = window.innerHeight;
  scopingOverlay.style.display = 'none';

  scopingContext = scopingOverlay.getContext('2d')

  crosshairOverlay = document.createElement('canvas')
  crosshairOverlay.style.zIndex="2000";//above all else
  crosshairOverlay.style.position = 'absolute';
  crosshairOverlay.style.left = '0px';
  crosshairOverlay.style.top = '0px';
  crosshairOverlay.id = "crosshairOverlay"
  crosshairOverlay.width = window.innerWidth;
  crosshairOverlay.height = window.innerHeight;
  crosshairOverlay.style.display = 'none';

  crosshairContext = crosshairOverlay.getContext('2d')


  canvasContainer.appendChild(weaponCanvas)
  canvasContainer.appendChild(overlayCanvas);
  canvasContainer.appendChild(scopingOverlay);
  canvasContainer.appendChild(crosshairOverlay);
  return overlayCanvas;
}

function drawOverlay() {
  var context = overlay.getContext('2d');
  context.clearRect(0, 0, overlay.width, overlay.height);
  var x = 10;
  var y = 40;
  context.font = "20pt Calibri";
  context.fillStyle = "#0000ff"; // text color
  context.fillText("sniper.io ", x, y);

  var weaponCanvas = document.getElementById('weaponCanvas')
  var weaponContext = weaponCanvas.getContext('2d')

  weaponContext.clearRect(0, 0, weaponCanvas.width, weaponCanvas.height);
  var scale = new THREE.Vector2(weaponCanvas.width/weapon.width, weaponCanvas.height/weapon.height)
  var left = overlay.width * 0.66;
  var top = overlay.height * 0.6;
  weaponContext.drawImage(weapon.image, 0, 0, weapon.width*scale.x, weapon.height * scale.y);

  scopingContext.save()
  scopingContext.fillStyle = 'rgba(0, 0, 0, 1)';
  scopingContext.fillRect(0, 0, window.innerWidth, window.innerHeight)

  // Set global composite operation to destination-out
  scopingContext.globalCompositeOperation = 'destination-out';

  // Draw circle
  scopingContext.strokeStyle = "#FFFFFF";

  var centerX = window.innerWidth/2, centerY = window.innerHeight/2
  var radius = ((window.innerWidth)/(window.innerHeight))*75
  var crosshairadius = ((window.innerWidth)/(window.innerHeight))*10

  scopingContext.beginPath();
  scopingContext.arc(centerX, centerY, radius, 0, Math.PI*2, false);
  scopingContext.fill();

  var isScoping = controls.isScoping()
  crosshairContext.save()
  crosshairContext.clearRect(0, 0, crosshairOverlay.width, crosshairOverlay.height);//clearRect(centerX - radius, centerY - radius, centerX + radius, centerY + radius)
  crosshairContext.beginPath()
  if(isScoping == true){
    crosshairContext.moveTo(centerX - radius, centerY)
    crosshairContext.lineTo(centerX + radius, centerY)
    crosshairContext.moveTo(centerX, centerY - radius)
    crosshairContext.lineTo(centerX, centerY + radius)
    crosshairContext.stroke();
  }else if(isScoping == false){
    crosshairContext.moveTo(centerX - crosshairadius, centerY)
    crosshairContext.lineTo(centerX + crosshairadius, centerY)
    crosshairContext.moveTo(centerX, centerY - crosshairadius)
    crosshairContext.lineTo(centerX, centerY + crosshairadius)
    crosshairContext.stroke();
  }


  context.restore();
  weaponContext.restore();
  scopingContext.restore();
  crosshairContext.restore();
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize( window.innerWidth, window.innerHeight );
}

function onSocketConnected() {
  console.log("Connected to socket server "+socket.id);
  var pos = controls.getPos()
  socket.emit("mapData")
  socket.emit("new player", {id: socket.id});
};

function onSocketDisconnect() {
  // console.log("Disconnected from socket server");
};

var ballGeometry = new THREE.SphereGeometry(0.4, 32, 32);

function onNewPlayer(data) {
  // console.log("New player connected: "+data.id);

  var mass = 50, radius = 0.8, playerHeight = 2;

  var size = new CANNON.Vec3(radius, radius, radius)
  var bodyShape = new CANNON.Sphere(radius)//new CANNON.Box(size)
  var body = new CANNON.Body({ mass: mass });
  body.linearDamping = 0.9;

  sphereBody.angularDamping = 0.5
  sphereBody.updateMassProperties();

  var shape = new THREE.SphereGeometry(bodyShape.radius, 32, 32);
  var mesh = new THREE.Mesh( ballGeometry, material );

  var newPlayer = new RemotePlayer(body, mesh)
  newPlayer.id = data.id
  newPlayer.setPos(new CANNON.Vec3(data.x, data.y, data.z))

  newPlayer.getBody().addShape(bodyShape);
  addPhysicsBody(newPlayer.getBody());
  scene.add(newPlayer.getMesh())
  remotePlayers.push(newPlayer)
};

function onHitPlayer(data){
  var hitPlayer = playerById(data.id)

  if(!hitPlayer && socket.id != data.id){
    console.log("(hit) player not found: "+data.id)
  }

  if(socket.id == data.id){
    console.log("You've been hit!")
  }
}

function onRemovePlayer(data) {
  var removePlayer = playerById(data.id);

  if (!removePlayer) {
    console.log("Player not found: "+data.id);
    return;
  };

  scene.remove(removePlayer.getMesh())
  world.remove(removePlayer.getBody())

  remotePlayers.splice(remotePlayers.indexOf(removePlayer), 1);
};

function playerById(id) {
  var i;
  for (i = 0; i < remotePlayers.length; i++) {
    if (remotePlayers[i].id == id)
    return remotePlayers[i];
  };

  return false;
};

function animate() {
  stats.begin()
  controls.update( Date.now() - time );

  var inputs = controls.inputs()
  // if(inputs.left || inputs.right || inputs.forward || inputs.backward || inputs.jump){
  socket.emit("move player", {id: socket.id, inputs: inputs});
  // }


  if(cannonDebugRenderer)
    cannonDebugRenderer.update()

  renderer.render( scene, camera );
  drawOverlay()

  stats.end()
  time = Date.now();

  requestAnimationFrame( animate );
}

function getRemotePlayerObjects(){
  var objects = []
  for(var o = 0; o < remotePlayers.length; o++){
    objects.push(remotePlayers[o].getMesh())
  }
  return objects
}

function getRemotePlayerFromObject(obj){
  for(var o = 0; o < remotePlayers.length; o++){
    if(remotePlayers[o].getMesh() == obj){
      return remotePlayers[o]
    }
  }
  return false
}

window.addEventListener("click",function(e){
  if(controls.enabled == true){
    raycaster.set(camera.getWorldPosition(), camera.getWorldDirection())
    var objects = getRemotePlayerObjects()
    var intersects = raycaster.intersectObjects(objects)

    if(intersects.length > 0){
      var shotPlayer = intersects[0].object
      var remotePlayer = getRemotePlayerFromObject(shotPlayer)
      console.log("Hit: "+remotePlayer.id)
      socket.emit("hit player", {id: remotePlayer.id});
    }
  }
});

</script>
</body>
</html>
