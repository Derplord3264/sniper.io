<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>sniper.io</title>
  <style>
  html, body {
    width: 100%;
    height: 100%;
  }
  body {
    background-color: #ffffff;
    margin: 0;
    overflow: hidden;
    font-family: arial;
  }
  #blocker {
    position: absolute;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.5);
  }
  #instructions {
    width: 100%;
    height: 100%;
    display: -webkit-box;
    display: -moz-box;
    display: box;
    -webkit-box-orient: horizontal;
    -moz-box-orient: horizontal;
    box-orient: horizontal;
    -webkit-box-pack: center;
    -moz-box-pack: center;
    box-pack: center;
    -webkit-box-align: center;
    -moz-box-align: center;
    box-align: center;
    color: #ffffff;
    text-align: center;
    cursor: pointer;
  }

  #canvasContainer {
    z-index: -10
  }
  </style>
</head>
<body>
  <!-- <script src="libraries/socket.io.js"></script> -->
  <script src="http://sniper.satvik.co/socket.io/socket.io.js"></script>
  <script src="http://sniper.satvik.co/libraries/three.min.js"></script>
  <script src="http://sniper.satvik.co/libraries/cannon.min.js"></script>

  <!-- <script src="libraries/three.min.js"></script>
  <script src="libraries/cannon.min.js"></script> -->
  <script src="http://sniper.satvik.co/debug/Stats.js"></script>
  <script src="http://sniper.satvik.co/debug/CannonDebugRenderer.js"></script>
  <script src="http://sniper.satvik.co/js/pointerlockcontrols.js"></script>
  <script src="http://sniper.satvik.co/js/stage.js"></script>
  <script src="http://sniper.satvik.co/remotePlayer.js"></script>
  <!-- <script src="libraries/require.js"></script> -->

  <div id="blocker" style="z-index: 3000;">
    <div id="instructions">
      <span style="font-size:40px; ">SNIPER.IO</span>
      <br />
      (W,A,S,D : Move, SPACE : Jump, MOUSE : Look, CLICK : Shoot, L-Shift : Scope)
    </div>
  </div>

  <!-- <div id="container">
  <div id="threeContainer"></div>
</div> -->
<!-- <div id="container">
<canvas id="canvas" style="width:100%;height:95%;border:1px gray solid;"></canvas>
</div> -->

<script>
var sphereShape, sphereBody, world, physicsMaterial;
var cannonDebugRenderer;
var camera, scene, renderer, raycaster;
var geometry, material, mesh;
var width, height;
var controls,time = Date.now();
var blocker = document.getElementById( 'blocker' );
var instructions = document.getElementById( 'instructions' );
var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;


var socket;
var remotePlayers;
var localPlayer;

var dt = 1/60;

var stats = new Stats();


// document.getElementById("container").style.display = 'none';
var container;
var canvas;// = document.getElementById('canvas');
var overlay = null;
var scopingOverlay = null, scopingContext;
var crosshairOverlay = null, crosshairContext;

var weapon = new Bitmap('assets/GunSmall.png', 16, 10);


if ( havePointerLock ) {
  var element = document.body;
  var pointerlockchange = function ( event ) {
    if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
      controls.enabled = true;
      blocker.style.display = 'none';
      crosshairOverlay.style.display = '';
    } else {
      controls.enabled = false;
      blocker.style.display = '-webkit-box';
      blocker.style.display = '-moz-box';
      blocker.style.display = 'box';
      instructions.style.display = '';
    }
  }
  var pointerlockerror = function ( event ) {
    instructions.style.display = '';
    crosshairOverlay.style.display = 'none';
  }
  // Hook pointer lock state change events
  document.addEventListener( 'pointerlockchange', pointerlockchange, false );
  document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
  document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );
  document.addEventListener( 'pointerlockerror', pointerlockerror, false );
  document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
  document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );
  instructions.addEventListener( 'click', function ( event ) {
    instructions.style.display = 'none';
    crosshairOverlay.style.display = '';
    // Ask the browser to lock the pointer
    element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
    if ( /Firefox/i.test( navigator.userAgent ) ) {
      var fullscreenchange = function ( event ) {
        if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {
          document.removeEventListener( 'fullscreenchange', fullscreenchange );
          document.removeEventListener( 'mozfullscreenchange', fullscreenchange );
          element.requestPointerLock();
        }
      }
      document.addEventListener( 'fullscreenchange', fullscreenchange, false );
      document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );
      element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;
      element.requestFullscreen();


    } else {
      element.requestPointerLock();
    }
    // console.log("unhide")
    document.getElementById("container").style.display = '';
  }, false );
} else {
  instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
}

// initCannon();
init();
animate();

// function initCannon(){
//   // Setup our world
//   world = new CANNON.World();
//   world.quatNormalizeSkip = 0;
//   world.quatNormalizeFast = false;
//   var solver = new CANNON.GSSolver();
//   world.defaultContactMaterial.contactEquationStiffness = 1e9;
//   world.defaultContactMaterial.contactEquationRelaxation = 4;
//   solver.iterations = 7;
//   solver.tolerance = 0.1;
//   var split = true;
//   if(split)
//   world.solver = new CANNON.SplitSolver(solver);
//   else
//   world.solver = solver;
//   world.gravity.set(0,-20,0);
//   world.broadphase = new CANNON.NaiveBroadphase();
//   // Create a slippery material (friction coefficient = 0.0)
//   physicsMaterial = new CANNON.Material("slipperyMaterial");
//   var physicsContactMaterial = new CANNON.ContactMaterial(physicsMaterial, physicsMaterial, 0.0, 0.3);
//   // We must add the contact materials to the world
//   world.addContactMaterial(physicsContactMaterial);
//
//   // Create a sphere
//   var mass = 50, radius = 0.8, playerHeight = 2;
//   var size = new CANNON.Vec3(radius, radius, radius)
//   sphereShape = new CANNON.Sphere(radius)//new CANNON.Box(size)
//   sphereBody = new CANNON.Body({ mass: mass });
//   sphereBody.addShape(sphereShape);
//   sphereBody.position.set(0,2,-10);
//   sphereBody.linearDamping = 0.9;
//   // sphereBody.inertia.set(0, 0, 0);
//   // sphereBody.invInertia.set(0, 0, 0);
//
//   sphereBody.angularDamping = 0.5
//   // sphereBody.fixedRotation = true
//   sphereBody.updateMassProperties();
//   world.addBody(sphereBody);
//   // Create a plane
//   var groundShape = new CANNON.Plane(); //inf size
//   var groundBody = new CANNON.Body({ mass: 0 });
//   groundBody.addShape(groundShape);
//   groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
//   world.addBody(groundBody);
// }


function initMap(){
  cw.world = new CANNON.World();
  cw.world.quatNormalizeSkip = 0;
  cw.world.quatNormalizeFast = false;

  var solver = new CANNON.GSSolver();
  cw.world.defaultContactMaterial.contactEquationStiffness = 1e9;
  cw.world.defaultContactMaterial.contactEquationRelaxation = 4;
  solver.iterations = 7;
  solver.tolerance = 0.1;
  var split = true;
  if(split)
    cw.world.solver = new CANNON.SplitSolver(solver);
  else
    cw.world.solver = solver;
  cw.world.gravity.set(0,-20,0);
  cw.world.broadphase = new CANNON.NaiveBroadphase();
  // Create a slippery material (friction coefficient = 0.0)
  physicsMaterial = new CANNON.Material("slipperyMaterial");
  var physicsContactMaterial = new CANNON.ContactMaterial(physicsMaterial, physicsMaterial, 0.0, 0.3);
  // We must add the contact materials to the world
  cw.world.addContactMaterial(physicsContactMaterial);

  //Ground plane
  var groundShape = new CANNON.Plane(); //inf size
  var groundBody = new CANNON.Body({ mass: 0 });
  groundBody.addShape(groundShape);
  groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
  addPhysicsBody(groundBody);

  createStage()
};

function addPhysicsBody(body){
  cw.world.addBody(body)
}

function updatePhysics(){
  cw.world.step(dt)
}

var cw = {} // Cannon World
var map = {}
var n;
var models = {}
var worldSize = 50
var tileWidth;

function createStage(){

  var bodies = []

  var boundaryThickness = 10
  var boundaryHeight = 10
  var boundarySize = new CANNON.Vec3(worldSize-(boundaryThickness), boundaryHeight, boundaryThickness)

  for(var i = 0; i < 4; i++){
    var boundarySideShape = new CANNON.Box(boundarySize)
    var boundarySideGeometry = new THREE.BoxGeometry(boundarySize.x*2, boundarySize.y*2, boundarySize.z*2);

    var rotation = (- Math.PI / 2)*i
    boundarySideGeometry.applyMatrix( new THREE.Matrix4().makeRotationY( rotation ) );

    var boundaryBody = new CANNON.Body({mass: 0})
    boundaryBody.addShape(boundarySideShape)
    // boundaryBody.wireframe
    boundaryBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0,1,0), rotation); //Match rotaion of geometry

    var boundaryMesh  = new THREE.Mesh(boundarySideGeometry, material)

    // var zSign =
    var zChange = 0
    var xChange = 0

    switch (i) {
      case 0:
      zChange = -worldSize
      xChange = 0
      break;
      case 1:
      zChange = 0
      xChange = -worldSize
      break;
      case 2:
      zChange = worldSize
      xChange = 0
      break;
      case 3:
      zChange = 0
      xChange = worldSize
      break;
      default:

    }

    boundaryBody.position.set(xChange, 0, zChange)
    boundaryMesh.position.set(xChange, 0, zChange)
    boundaryMesh.castShadow = false;

    // meshes.push(boundaryMesh)
    bodies.push(boundaryBody)
  }

  loadModels()

  for(var i = 0; i < n*n; i++){
    //Create physics bodies
    if(map[i] > 0){
      // console.log("map ")
      createHouse(map[i]-1, i)
    }
  }

}


function loadModels(){

  // function loadJSON(callback, path) {
  //   var xobj = new XMLHttpRequest();
  //   xobj.overrideMimeType("application/json");
  //   xobj.open('GET', path, true); // Replace 'my_data' with the path to your file
  //   xobj.onreadystatechange = function () {
  //       if (xobj.readyState == 4 && xobj.status == "200") {
  //         // Required use of an anonymous callback as .open will NOT return a value but simply returns undefined in asynchronous mode
  //         callback(xobj.responseText);
  //       }else{
  //         // console.log("other "+xobj.status);
  //       }
  //     };
  //     xobj.send(null);
  //  }



  var numModels = 1
  for(var m = 0; m < numModels; m++){
    // loadJSON(function(response){
    //   models[m] = response
    // }, "public/assets/models/house"+m+".json")
    // models[m] = fs.readFileSync()


    var request = new XMLHttpRequest();
    // http://sniper.satvik.co/assets/models/house0.json
    request.open('GET', '/assets/models/house'+m+'.json', false);  // `false` makes the request synchronous
    request.send(null);
    // console.log("req for model: ("+m+")"+request.responseText)
    if (request.status === 200) {
      // console.log("Load model "+m);
      models[m] = request.responseText;
    }

  }
}

function createHouse(num, gridTile){

   var response = models[num]
  //  console.log("res: ("+num+")"+response)
   // Parse JSON string into object
   var json = JSON.parse(response)
   var objs = json["objs"];
   var metadata = json["metadata"]
   var height = metadata[0]["totalHeight"]
   var width = metadata[0]["totalWidth"]

   var newScale = tileWidth/width
   var gridPos = new CANNON.Vec3((gridTile%n)*tileWidth, 0, (gridTile/n)*tileWidth)


   function vectorFromJSON(jsonVector){
     return new CANNON.Vec3(jsonVector["x"], jsonVector["y"], jsonVector["z"])
   }

   function quatFromJSON(jsonVector){
     return new THREE.Quaternion(jsonVector["x"], jsonVector["y"], jsonVector["z"], jsonVector["w"])
   }

  //  console.log("NS: "+newScale)

   for(var i = 0; i < objs.length; i++){
     var obj = objs[i];
     var pos = vectorFromJSON(obj["pos"])
     var scale = vectorFromJSON(obj["scale"])
     var rot = quatFromJSON(obj["rot"])

    //  scale.x = scale.x*newScale
    //  scale.y = scale.y*newScale
    //  scale.z = scale.z*newScale

    //  var boxShape = new CANNON.Box(scale)
     //
    //  var boxBody = new CANNON.Body({mass: 0})
    //  boxBody.addShape(boxShape)
    //  boxBody.quaternion.set(rot.x, rot.y, rot.z, rot.w) //Match rotaion of geometry
    //  boxBody.position.set(pos.x, pos.y+height, pos.z)
     //
    //  cw.world.addBody(boxBody)

    var boxShape = new CANNON.Box(scale)
    var boxGeometry = new THREE.BoxGeometry(scale.x*2, scale.y*2, scale.z*2);

    var material = new THREE.MeshPhongMaterial( { color: 0xdddddd} ); //TODO MeshBasicMaterial?
    material.shininess = 0.5
    material.transparent = false

    var boxBody = new CANNON.Body({mass: 0})
    boxBody.addShape(boxShape)

    // var rotationInterval = Math.PI/2
    // var ogQuat = new THREE.Quaternion(rot.x, rot.y, rot.z, rot.w)
    // var q1 = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), rotationInterval)
    //
    // var finalQuat = ogQuat.multiplyQuaternions(q1, ogQuat)
    // boxBody.position.set(0, 0, 0)
    // boxBody.quaternion.set(finalQuat.x, finalQuat.y, finalQuat.z, finalQuat.w)

    // boxBody.quaternion.set(rot.x, rot.y, rot.z, rot.w) //Match rotaion of geometry
    var boxMesh  = new THREE.Mesh(boxGeometry, material)
    boxMesh.setRotationFromQuaternion(new THREE.Quaternion(rot.x, rot.y, rot.z, rot.w))
    // boxMesh.position.set(0, 0, 0)
    // boxMesh.setRotationFromQuaternion(new THREE.Quaternion(finalQuat.x, finalQuat.y, finalQuat.z, finalQuat.w))

    boxMesh.receiveShadow = true
    boxMesh.castShadow = true
    boxMesh.shadowBias = -0.0008
    boxMesh.position.set(gridPos.x+pos.x, pos.y+height, gridPos.z+pos.z)
    boxBody.position.set(gridPos.x+pos.x, pos.y+height, gridPos.z+pos.z)

    scene.add(boxMesh)
    addPhysicsBody(boxBody)
   }
}

function Bitmap(src, width, height) {
  this.image = new Image();
  this.image.src = src;
  this.width = width;
  this.height = height;
}

function init() {
  container = document.createElement('div')
  container.id = "container"
  document.body.appendChild(container);

  canvas = document.createElement('canvas')
  canvas.id = "canvas"
  container.appendChild(canvas)

  if(!overlay){
    overlay = createOverlay(canvas)
  }


  stats.showPanel( 0 ); // 0: fps, 1: ms, 2: mb, 3+: custom
  document.body.appendChild( stats.dom );


  camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x00bfff)
  // scene.fog = new THREE.Fog( 0x000000, 0, 500 );
  var ambient = new THREE.AmbientLight( 0x404040, 0.5 );
  scene.add( ambient );
  // light = new THREE.DirectionalLight( 0xffffff, 1 );
  // light.position.set( 10, 30, 20 );
  // light.target.position.set( 0, 0, 0 );
  // if(true){
  //   light.castShadow = true;
  //   light.shadowCameraNear = 20;
  //   light.shadowCameraFar = 50;//camera.far;
  //   light.shadowCameraFov = 40;
  //   // light.shadowMapBias = 0.1;
  //   // light.shadowMapDarkness = 0.7;
  //   // light.shadowMapWidth = 2*512;
  //   // light.shadowMapHeight = 2*512;
  //   //light.shadowCameraVisible = true;
  // }
  // scene.add( light );
  //
  // var oppLight = new THREE.DirectionalLight( 0xffffff, 1 );
  // oppLight.position.set( -10, 30, -20 );
  // oppLight.target.position.set( 0, 0, 0 );
  // if(true){
  //   oppLight.castShadow = false;
  //   oppLight.shadowCameraNear = 20;
  //   oppLight.shadowCameraFar = 50;//camera.far;
  //   oppLight.shadowCameraFov = 40;
  //   // light.shadowMapBias = 0.1;
  //   // light.shadowMapDarkness = 0.7;
  //   // light.shadowMapWidth = 2*512;
  //   // light.shadowMapHeight = 2*512;
  //   //light.shadowCameraVisible = true;
  // }
  // scene.add( oppLight );

  var hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
  hemiLight.color.setHSL( 0.6, 1, 0.6 );
  hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
  hemiLight.position.set( 0, 500, 0 );
  scene.add( hemiLight );

  var dirLight = new THREE.DirectionalLight( 0xffffff, 0.8 );
  dirLight.position.set( -135, 146, 50 );
  // dirLight.position.multiplyScalar( 50);
  dirLight.name = "dirlight";
  dirLight.target.position.set(0, 0, 0)
  // dirLight.shadowCameraVisible = true;

  var shadowHelper = new THREE.CameraHelper( dirLight.shadow.camera );
  scene.add(shadowHelper);

  var d = 200;
  dirLight.shadow.camera.left = -d;
  dirLight.shadow.camera.right = d;
  dirLight.shadow.camera.top = d;
  dirLight.shadow.camera.bottom = -d;
  scene.add( dirLight );

  dirLight.castShadow = true;
  dirLight.shadow.mapSize.width = dirLight.shadow.mapSize.height = 1024*2;
  dirLight.shadow.bias = -0.0007;
  // dirLight.shadowDarkness = 0;

  var helper = new THREE.DirectionalLightHelper( dirLight );
  scene.add(helper);



  // Create a sphere
  var mass = 50, radius = 0.8, playerHeight = 2;
  var size = new CANNON.Vec3(radius, radius, radius)
  sphereShape = new CANNON.Sphere(radius)//new CANNON.Box(size)
  sphereBody = new CANNON.Body({ mass: mass });
  sphereBody.addShape(sphereShape);
  sphereBody.position.set(0,2,-10);
  sphereBody.linearDamping = 0.9;
  // sphereBody.inertia.set(0, 0, 0);
  // sphereBody.invInertia.set(0, 0, 0);

  localPlayer = new RemotePlayer(sphereBody, null)
  // console.log("local player")

  controls = new PointerLockControls( camera , sphereBody );
  controls.oldPos = new THREE.Vector3().copy(controls.getObject().position)
  scene.add( controls.getObject() );

  // floor
  geometry = new THREE.PlaneGeometry( 300, 300, 50, 50 );
  geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );
  material = new THREE.MeshLambertMaterial( { color: 0xffffff } );
  mesh = new THREE.Mesh( geometry, material );
  // mesh.castShadow = true;
  mesh.receiveShadow = true;
  scene.add( mesh );


  raycaster = new THREE.Raycaster()

  renderer = new THREE.WebGLRenderer({canvas: canvas});
  renderer.shadowMap.enabled = true;
  renderer.shadowMapSoft = true;

  // renderer.shadowCameraFar = camera.far;
  // renderer.shadowCameraFov = 75;
  // renderer.shadowCameraNear = 0.1;

  renderer.setSize( window.innerWidth, window.innerHeight );
  // makeStage()

  var axisHelper = new THREE.AxisHelper( 5 );
  scene.add( axisHelper );



  // renderer.setClearColor( scene.fog.color, 1 );
  // document.getElementById("threeContainer").appendChild( renderer.domElement );
  window.addEventListener( 'resize', onWindowResize, false );

  cannonDebugRenderer = new THREE.CannonDebugRenderer(scene, world);

  remotePlayers = [];

  socket = io.connect("http://sniper.satvik.co")//("http://localhost", {port: 8000, transports: ["websocket"]});
  setSocketEventHandlers()

}

function setSocketEventHandlers(){
  socket.on("connect", onSocketConnected);
  socket.on("disconnect", onSocketDisconnect);
  socket.on("new player", onNewPlayer);
  socket.on("move player", onMovePlayer);
  socket.on("hit player", onHitPlayer);
  socket.on("remove player", onRemovePlayer);
  socket.on("mapData", onMapData);
  socket.on("updatePlayers", onUpdatePlayers);
}

function onMapData(data){
  // console.log("Got map data "+data.n+" "+data.map[0])
  map = data.map
  n = data.n
  tileWidth = (worldSize*2)/n
  initMap()
}

// function makeStage(){
//   var stage = createStage()
//   var meshes = stage[0]
//   var bodies = stage[1]
//
//   var numMeshes = meshes.length
//   var numBodies = bodies.length
//
//   // if(numMeshes == numBodies){
//     for(var i = 0; i < numMeshes; i++){
//       var mesh = meshes[i]
//       var body = bodies[i]
//
//       // var box = new THREE.BoxHelper( mesh, 0xffff00 );
//       // scene.add( box );
//
//       // Because the stage is static we don't add them to a array for updating
//       if(mesh) scene.add(mesh)
//       if(body) world.addBody(body)
//     }
//   // }
// }

function onUpdatePlayers(data){
  var playerData = data.data
  for(var p = 0; p < playerData.length; p++){
    var id = playerData[p].id
    var position = playerData[p].position
    // console.log("UP: "+p+" "+id)
    var player = playerById(id)

    if(!player && id != socket.id){
      return
    }

    // console.log("p2: "+position.x+" "+position.y+" "+position.z)
    if(socket.id == id){
      localPlayer.setPos(position)
    }else{
      player.setPos(position)
    }
  }
}


function createOverlay(mainCanvas){
  var canvasContainer = document.getElementById('container');
  var overlayCanvas = document.createElement('canvas');
  overlayCanvas.style.zIndex="1000";
  overlayCanvas.style.position = 'absolute';
  overlayCanvas.style.left = '0px';
  overlayCanvas.style.top = '0px';
  overlayCanvas.id = "overlay"
  overlayCanvas.width = mainCanvas.width;
  overlayCanvas.height = mainCanvas.height;

  var weaponCanvas = document.createElement('canvas')
  weaponCanvas.id = "weaponCanvas"
  // weaponCanvas.width = window.innerWidth
  // weaponCanvas.height = window.innerHeight
  weaponCanvas.style.zIndex = "1001"
  weaponCanvas.style.position = 'absolute';
  weaponCanvas.style.right = '0px';
  weaponCanvas.style.bottom = '0px';
  weaponCanvas.getContext('2d').imageSmoothingEnabled = false
  weaponCanvas.getContext('2d').transform(0.65,0.5,0,1,85,0);

  //scoping overlay
  scopingOverlay = document.createElement('canvas')
  scopingOverlay.style.zIndex="1002";//above weapon
  scopingOverlay.style.position = 'absolute';
  scopingOverlay.style.left = '0px';
  scopingOverlay.style.top = '0px';
  scopingOverlay.id = "scopingOverlay"
  scopingOverlay.width = window.innerWidth;
  scopingOverlay.height = window.innerHeight;
  scopingOverlay.style.display = 'none';

  scopingContext = scopingOverlay.getContext('2d')

  crosshairOverlay = document.createElement('canvas')
  crosshairOverlay.style.zIndex="2000";//above all else
  crosshairOverlay.style.position = 'absolute';
  crosshairOverlay.style.left = '0px';
  crosshairOverlay.style.top = '0px';
  crosshairOverlay.id = "crosshairOverlay"
  crosshairOverlay.width = window.innerWidth;
  crosshairOverlay.height = window.innerHeight;
  crosshairOverlay.style.display = 'none';

  crosshairContext = crosshairOverlay.getContext('2d')


  canvasContainer.appendChild(weaponCanvas)
  canvasContainer.appendChild(overlayCanvas);
  canvasContainer.appendChild(scopingOverlay);
  canvasContainer.appendChild(crosshairOverlay);
  return overlayCanvas;
}

function drawOverlay() {
  var context = overlay.getContext('2d');
  context.clearRect(0, 0, overlay.width, overlay.height);
  var x = 10;
  var y = 40;
  context.font = "20pt Calibri";
  context.fillStyle = "#0000ff"; // text color
  context.fillText("sniper.io ", x, y);

  var weaponCanvas = document.getElementById('weaponCanvas')
  var weaponContext = weaponCanvas.getContext('2d')

  weaponContext.clearRect(0, 0, weaponCanvas.width, weaponCanvas.height);
  var scale = new THREE.Vector2(weaponCanvas.width/weapon.width, weaponCanvas.height/weapon.height)
  var left = overlay.width * 0.66;
  var top = overlay.height * 0.6;
  weaponContext.drawImage(weapon.image, 0, 0, weapon.width*scale.x, weapon.height * scale.y);

  scopingContext.save()
  scopingContext.fillStyle = 'rgba(0, 0, 0, 1)';
  scopingContext.fillRect(0, 0, window.innerWidth, window.innerHeight)

  // Set global composite operation to destination-out
  scopingContext.globalCompositeOperation = 'destination-out';

  // Draw circle
  scopingContext.strokeStyle = "#FFFFFF";

  var centerX = window.innerWidth/2, centerY = window.innerHeight/2
  var radius = ((window.innerWidth)/(window.innerHeight))*75
  var crosshairadius = ((window.innerWidth)/(window.innerHeight))*10

  // scopingContext.globalCompositeOperation = 'source-in';
  scopingContext.beginPath();
  scopingContext.arc(centerX, centerY, radius, 0, Math.PI*2, false);
  scopingContext.fill();

  var isScoping = controls.isScoping()
  crosshairContext.save()
  crosshairContext.clearRect(0, 0, crosshairOverlay.width, crosshairOverlay.height);//clearRect(centerX - radius, centerY - radius, centerX + radius, centerY + radius)
  crosshairContext.beginPath()
  if(isScoping == true){
    crosshairContext.moveTo(centerX - radius, centerY)
    crosshairContext.lineTo(centerX + radius, centerY)
    crosshairContext.moveTo(centerX, centerY - radius)
    crosshairContext.lineTo(centerX, centerY + radius)
    crosshairContext.stroke();
  }else if(isScoping == false){
    crosshairContext.moveTo(centerX - crosshairadius, centerY)
    crosshairContext.lineTo(centerX + crosshairadius, centerY)
    crosshairContext.moveTo(centerX, centerY - crosshairadius)
    crosshairContext.lineTo(centerX, centerY + crosshairadius)
    crosshairContext.stroke();
  }


  context.restore();
  weaponContext.restore();
  scopingContext.restore();
  crosshairContext.restore();
}

function onWindowResize() {
  // scopingOverlay.width = window.innerWidth;
  // scopingOverlay.height = window.innerHeight;

  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize( window.innerWidth, window.innerHeight );


}

function onSocketConnected() {
    console.log("Connected to socket server "+socket.id);
    var pos = controls.getPos()
    // controls.id =
    socket.emit("mapData")
    socket.emit("new player", {id: socket.id});
};

function onSocketDisconnect() {
    // console.log("Disconnected from socket server");
};

var ballGeometry = new THREE.SphereGeometry(0.4, 32, 32);

function onNewPlayer(data) {
    console.log("New player connected: "+data.id);

    var mass = 50, radius = 0.8, playerHeight = 2;

    var size = new CANNON.Vec3(radius, radius, radius)
    var bodyShape = new CANNON.Sphere(radius)//new CANNON.Box(size)
    var body = new CANNON.Body({ mass: mass });
    body.linearDamping = 0.9;
    // sphereBody.inertia.set(0, 0, 0);
    // sphereBody.invInertia.set(0, 0, 0);

    sphereBody.angularDamping = 0.5
    // sphereBody.fixedRotation = true
    sphereBody.updateMassProperties();



    var shape = new THREE.SphereGeometry(bodyShape.radius, 32, 32);
    var mesh = new THREE.Mesh( ballGeometry, material );


    var newPlayer = new RemotePlayer(body, mesh)
    newPlayer.id = data.id
    newPlayer.setPos(new CANNON.Vec3(data.x, data.y, data.z))

    newPlayer.getBody().addShape(bodyShape);
    cw.world.addBody(newPlayer.getBody());
    scene.add(newPlayer.getMesh())
    remotePlayers.push(newPlayer)


};

function onMovePlayer(data) {
  // var movePlayer = playerById(data.id);
  //
  // if (!movePlayer) {
  //     console.log("Player not found: "+data.id);
  //     return;
  // };
  // // console.log("Moving player "+data.id)
  // movePlayer.setPos(new CANNON.Vec3(data.x, data.y, data.z))
};

function onHitPlayer(data){
  var hitPlayer = playerById(data.id)

  if(!hitPlayer && socket.id != data.id){
    console.log("(hit) player not found: "+data.id)
  }

  if(socket.id == data.id){
    console.log("You've been hit!")
  }
}

function onRemovePlayer(data) {
  var removePlayer = playerById(data.id);

  if (!removePlayer) {
      console.log("Player not found: "+data.id);
      return;
  };

  scene.remove(removePlayer.getMesh())
  world.remove(removePlayer.getBody())

  remotePlayers.splice(remotePlayers.indexOf(removePlayer), 1);
};


function playerById(id) {
    var i;
    for (i = 0; i < remotePlayers.length; i++) {
        if (remotePlayers[i].id == id)
            return remotePlayers[i];
    };

    return false;
};

// function updateWorld(){
//
// }


function animate() {

  stats.begin()

  // if(controls.enabled){
    // world.step(dt);
    // Update ball positions
    // for(var i=0; i<balls.length; i++){
    //   ballMeshes[i].position.copy(balls[i].position);
    //   ballMeshes[i].quaternion.copy(balls[i].quaternion);
    // }


  controls.update( Date.now() - time );
  // if (controls.updateTestPos() == true) {
  //   var pos = controls.getObject().position
  //   // console.log("update move")
  //   socket.emit("move player", {id: socket.id, x: pos.x, y: pos.y, z: pos.z});
  // };

  var inputs = controls.inputs()
  // if(inputs.left || inputs.right || inputs.forward || inputs.backward || inputs.jump){
      socket.emit("move player", {id: socket.id, inputs: inputs});
  // }


  // console.log("Old: "+conrols.oldPos.x+" New: "+controls.getObject().position.x)

  // cannonDebugRenderer.update()
  renderer.render( scene, camera );
  drawOverlay()

  stats.end()

  time = Date.now();

  requestAnimationFrame( animate );
}

function getRemotePlayerObjects(){
  var objects = []
  for(var o = 0; o < remotePlayers.length; o++){
    objects.push(remotePlayers[o].getMesh())
  }
  return objects
}

function getRemotePlayerFromObject(obj){
  for(var o = 0; o < remotePlayers.length; o++){
    if(remotePlayers[o].getMesh() == obj){
      return remotePlayers[o]
    }
  }
  return false
}

window.addEventListener("click",function(e){
  if(controls.enabled == true){
    raycaster.set(camera.getWorldPosition(), camera.getWorldDirection())
    var objects = getRemotePlayerObjects()
    var intersects = raycaster.intersectObjects(objects)

    if(intersects.length > 0){
      var shotPlayer = intersects[0].object
      var remotePlayer = getRemotePlayerFromObject(shotPlayer)
      console.log("Hit: "+remotePlayer.id)
      socket.emit("hit player", {id: remotePlayer.id});
    }
  }
});

// THREE.Object3D.prototype.rotateAroundWorldAxis = function() {
//
//     // rotate object around axis in world space (the axis passes through point)
//     // axis is assumed to be normalized (important!)
//     // angle is in radians
//
//     var q1 = new THREE.Quaternion();
//
//     return function ( point, axis, angle ) {
//
//         q1.setFromAxisAngle( axis, angle );
//
//         this.quaternion.multiplyQuaternions( q1, this.quaternion );
//
//         this.position.sub( point );
//         this.position.applyQuaternion( q1 );
//         this.position.add( point );
//
//         return this;
//
//     }
//
// }();

</script>
</body>
</html>
