<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>sniper.io</title>
  <style>
  html, body {
    width: 100%;
    height: 100%;
  }
  body {
    background-color: #ffffff;
    margin: 0;
    overflow: hidden;
    font-family: arial;
  }
  #blocker {
    position: absolute;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.5);
  }
  #instructions {
    width: 100%;
    height: 100%;
    display: -webkit-box;
    display: -moz-box;
    display: box;
    -webkit-box-orient: horizontal;
    -moz-box-orient: horizontal;
    box-orient: horizontal;
    -webkit-box-pack: center;
    -moz-box-pack: center;
    box-pack: center;
    -webkit-box-align: center;
    -moz-box-align: center;
    box-align: center;
    color: #ffffff;
    text-align: center;
    cursor: pointer;
  }

  #canvasContainer {
    z-index: -10
  }
  </style>
</head>
<body>
  <script src="http://sniper.satvik.co/socket.io/socket.io.js"></script>
  <script src="http://sniper.satvik.co/libraries/three.min.js"></script>
  <script src="http://sniper.satvik.co/libraries/cannon.min.js"></script>

  <script src="http://sniper.satvik.co/debug/Stats.js"></script>
  <script src="http://sniper.satvik.co/debug/CannonDebugRenderer.js"></script>
  <script src="http://sniper.satvik.co/js/pointerlockcontrols.js"></script>
  <script src="http://sniper.satvik.co/js/stage.js"></script>
  <script src="http://sniper.satvik.co/remotePlayer.js"></script>

  <div id="blocker" style="z-index: 3000;">
    <div id="instructions">
      <span style="font-size:40px; ">SNIPER.IO</span>
      <br />
      (W,A,S,D : Move, SPACE : Jump, MOUSE : Look, CLICK : Shoot, L-Shift : Scope)
    </div>
  </div>
<script>
var sphereShape, sphereBody, physicsMaterial;
var cannonDebugRenderer;
var camera, scene, renderer, raycaster;
var geometry, material, mesh;
var width, height;
var controls,time = Date.now();
var blocker = document.getElementById( 'blocker' );
var instructions = document.getElementById( 'instructions' );
var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

var socket;
var remotePlayers;
var localPlayer;

var dt = 1/60;

var stats = new Stats();

var container;
var canvas;
var overlay = null;
var scopingOverlay = null, scopingContext;
var crosshairOverlay = null, crosshairContext;
var weaponOverlay = null, weaponContext;

var weapon = new Bitmap('assets/GunSmall.png', 16, 10);

if ( havePointerLock ) {
  var element = document.body;
  var pointerlockchange = function ( event ) {
    if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
      controls.enabled = true;
      blocker.style.display = 'none';
      crosshairOverlay.style.display = '';
    } else {
      controls.enabled = false;
      blocker.style.display = '-webkit-box';
      blocker.style.display = '-moz-box';
      blocker.style.display = 'box';
      instructions.style.display = '';
    }
  }
  var pointerlockerror = function ( event ) {
    instructions.style.display = '';
    crosshairOverlay.style.display = 'none';
  }
  // Hook pointer lock state change events
  document.addEventListener( 'pointerlockchange', pointerlockchange, false );
  document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
  document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );
  document.addEventListener( 'pointerlockerror', pointerlockerror, false );
  document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
  document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );
  instructions.addEventListener( 'click', function ( event ) {
    instructions.style.display = 'none';
    crosshairOverlay.style.display = '';
    // Ask the browser to lock the pointer
    element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
    if ( /Firefox/i.test( navigator.userAgent ) ) {
      var fullscreenchange = function ( event ) {
        if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {
          document.removeEventListener( 'fullscreenchange', fullscreenchange );
          document.removeEventListener( 'mozfullscreenchange', fullscreenchange );
          element.requestPointerLock();
        }
      }
      document.addEventListener( 'fullscreenchange', fullscreenchange, false );
      document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );
      element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;
      element.requestFullscreen();
    } else {
      element.requestPointerLock();
    }
    // console.log("unhide")
    document.getElementById("container").style.display = '';
  }, false );
} else {
  instructions.innerHTML = 'Oh well, your browser doesn\'t seem to support SNIPER.IO';
}

// initCannon();
init();
animate();

function initMap(){
  cw.world = new CANNON.World();
  cw.world.quatNormalizeSkip = 0;
  cw.world.quatNormalizeFast = false;

  var solver = new CANNON.GSSolver();
  cw.world.defaultContactMaterial.contactEquationStiffness = 1e9;
  cw.world.defaultContactMaterial.contactEquationRelaxation = 4;
  solver.iterations = 7;
  solver.tolerance = 0.1;
  var split = true;
  if(split)
  cw.world.solver = new CANNON.SplitSolver(solver);
  else
  cw.world.solver = solver;
  cw.world.gravity.set(0,-20,0);
  cw.world.broadphase = new CANNON.NaiveBroadphase();
  // Create a slippery material (friction coefficient = 0.0)
  physicsMaterial = new CANNON.Material("slipperyMaterial");
  var physicsContactMaterial = new CANNON.ContactMaterial(physicsMaterial, physicsMaterial, 0.0, 0.3);
  // We must add the contact materials to the world
  cw.world.addContactMaterial(physicsContactMaterial);

  //Ground plane
  var groundShape = new CANNON.Plane(); //inf size
  var groundBody = new CANNON.Body({ mass: 0 });
  groundBody.addShape(groundShape);
  groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
  addPhysicsBody(groundBody);

  cannonDebugRenderer = new THREE.CannonDebugRenderer(scene, cw.world);

  createStage()
};

function addPhysicsBody(body){
  cw.world.addBody(body)
}

function updatePhysics(){
  cw.world.step(dt)
}

var cw = {} // Cannon World
var map;
var n;
// var models = {}
var worldSize;
var tileWidth;
var tileHeight;
var boundaryThickness;
var boundaryHeight;
var boundaryWhitespace;

var slopeData;

var stage = new THREE.Geometry()

function createStage(){

  var boundarySize = new CANNON.Vec3(worldSize*2+(boundaryWhitespace*2), boundaryHeight, boundaryThickness)

  var boundaryMeshGeo = new THREE.Geometry()

  for(var i = 0; i < 4; i++){
    var halfExtents = new CANNON.Vec3(boundarySize.x/2, boundarySize.y/2, boundarySize.z/2)
    var boundarySideShape = new CANNON.Box(halfExtents)

    var rotation = (- Math.PI / 2)*i

    var boundaryBody = new CANNON.Body({mass: 0})
    boundaryBody.addShape(boundarySideShape)
    boundaryBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0,1,0), rotation); //Match rotaion of geometry

    var zChange = 0
    var xChange = 0

    switch (i) {
      case 0:
      zChange = -worldSize-boundaryWhitespace
      xChange = 0
      break;
      case 1:
      zChange = 0
      xChange = -worldSize-boundaryWhitespace
      break;
      case 2:
      zChange = worldSize+boundaryWhitespace
      xChange = 0
      break;
      case 3:
      zChange = 0
      xChange = worldSize+boundaryWhitespace
      break;
      default:
      break;
    }

    boundaryBody.position.set(xChange-(tileWidth/2), boundaryHeight/2, zChange-(tileWidth/2))

    addPhysicsBody(boundaryBody)


    var lineGeo = new THREE.Geometry()

    var v1 = new THREE.Vector3(-worldSize-boundaryWhitespace, 0, 0)
    var v2 = new THREE.Vector3(worldSize+boundaryWhitespace, 0, 0)

    lineGeo.vertices.push(v1)
    lineGeo.vertices.push(v2)
    lineGeo.applyMatrix( new THREE.Matrix4().makeRotationY( rotation ) );

    var mat = new THREE.LineBasicMaterial({color: 0x0000ff});
    var line = new THREE.Line(lineGeo, mat)
    line.position.set(xChange-(tileWidth/2), 0, zChange-(tileWidth/2))
    scene.add(line)
  }

  slopeData = this.createSlope(tileWidth, tileHeight)

  console.log("Layers: "+map.length)
  for(var l = 0; l < map.length; l++){
    for(var x = 0; x < n; x++){
      for(var y = 0; y < n; y++){

        if(map[l][x][y] > 0){
          this.createTile(x,y,l)
        }
      }
    }
  }

  var stageMesh = new THREE.Mesh(stage, houseMaterial)
  // stageMesh.castShadow = true
  // stageMesh.receiveShadow = true
  // stageMesh.shadowBias = -0.007
  scene.add(stageMesh)


  //debug lines
  // for(var x = 0; x < n; x++){
  //   var linePoints = new THREE.Geometry()
  //   linePoints.vertices.push(new THREE.Vector3(-worldSize-(tileWidth/2), 0.1, (x-(n/2))*tileWidth-(tileWidth/2)))
  //   linePoints.vertices.push(new THREE.Vector3(worldSize-(tileWidth/2), 0.1, (x-(n/2))*tileWidth-(tileWidth/2)))
  //
  //   var mat;
  //
  //   if(x == (n+1/2)){
  //     mat = new THREE.LineBasicMaterial({color: 0x0000ff})
  //   }else{
  //     mat = new THREE.LineBasicMaterial({color:0xff0000})
  //   }
  //
  //   var mesh = new THREE.Line(linePoints, mat)
  //   // scene.add(mesh)
  // }
  //
  // for(var y = 0; y < n; y++){
  //   var linePoints = new THREE.Geometry()
  //   linePoints.vertices.push(new THREE.Vector3((y-(n/2))*tileWidth-(tileWidth/2), 0.1, -worldSize-(tileWidth/2)))
  //   linePoints.vertices.push(new THREE.Vector3((y-(n/2))*tileWidth-(tileWidth/2), 0.1, worldSize-(tileWidth/2)))
  //
  //   var mat;
  //
  //   if(y == (n+1/2)){
  //     mat = new THREE.LineBasicMaterial({color: 0x0000ff})
  //   }else{
  //     mat = new THREE.LineBasicMaterial({color:0xff0000})
  //   }
  //
  //   var mesh = new THREE.Line(linePoints, mat)
  //   // scene.add(mesh)
  // }
}


var houseMaterial = new THREE.MeshLambertMaterial( { color: 0xdddddd} ); //TODO MeshBasicMaterial?

this.createTile = function(x, y, l){
  var tile = map[l][x][y]
  var gridPos = new CANNON.Vec3(-((x-(n/2))*tileWidth), l*tileHeight, (y-(n/2))*tileWidth)

  if(tile){
    if(tile == 0){
      return
    }

    if(tile == 1){
      var tWidth = tileWidth
      var tHeight = tileHeight

      var halfExtents = new CANNON.Vec3(tWidth/2, tHeight/2, tWidth/2)
      var boxShape = new CANNON.Box(halfExtents)

      var boxBody = new CANNON.Body({mass: 0})
      boxBody.addShape(boxShape)
      boxBody.position.set(gridPos.x, gridPos.y+(tileHeight/2), gridPos.z)


      var boxGeometry = new THREE.BoxGeometry(tWidth, tHeight, tWidth);
      var boxMesh  = new THREE.Mesh(boxGeometry, houseMaterial)
      boxMesh.position.set(gridPos.x, gridPos.y+(tileHeight/2), gridPos.z)
      boxMesh.updateMatrix()
      stage.merge(boxMesh.geometry, boxMesh.matrix)

      this.addPhysicsBody(boxBody)
    }

    if(tile == 2){
      var size = new CANNON.Vec3(tileWidth, tileHeight/8, tileWidth)
      var halfExtents = new CANNON.Vec3(size.x/2, size.y/2, size.z/2)
      var boxShape = new CANNON.Box(halfExtents)

      var boxBody = new CANNON.Body({mass: 0})
      boxBody.addShape(boxShape)
      boxBody.position.set(gridPos.x, gridPos.y+(tileHeight-size.y/2), gridPos.z)

      var boxGeometry = new THREE.BoxGeometry(size.x, size.y, size.z);
      var boxMesh  = new THREE.Mesh(boxGeometry, houseMaterial)
      boxMesh.position.set(gridPos.x, gridPos.y+(tileHeight-size.y/2), gridPos.z)
      boxMesh.updateMatrix()
      stage.merge(boxMesh.geometry, boxMesh.matrix)

      this.addPhysicsBody(boxBody)
    }

    //Slope 3-6
    if(tile >= 3 && tile <= 6){
      var dir = tile-3
      var rot = (Math.PI/2)*dir
      var slopeShape = new CANNON.ConvexPolyhedron(slopeData[0], slopeData[1])
      var slopeBody = new CANNON.Body({mass: 0})
      slopeBody.addShape(slopeShape)
      slopeBody.position.set(gridPos.x, gridPos.y+(tileHeight/2), gridPos.z)
      slopeBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0,1,0), rot); //Match rotaion of geometry
      this.addPhysicsBody(slopeBody)

      var slopeGeo = this.createSlopeGeo(slopeData[0], slopeData[1])
      slopeGeo.applyMatrix( new THREE.Matrix4().makeRotationY( rot ) );
      var mesh = new THREE.Mesh(slopeGeo, houseMaterial)
      mesh.position.set(gridPos.x, gridPos.y+(tileHeight/2), gridPos.z)

      mesh.updateMatrix()
      stage.merge(mesh.geometry, mesh.matrix)
    }
  }
}

function createSlope(width, height){
  var y2 = height/2
  var x2 = width/2
  var verts = [ new CANNON.Vec3(x2, -y2, -x2),
                new CANNON.Vec3(-x2, -y2, -x2),
                new CANNON.Vec3(-x2, -y2, x2),
                new CANNON.Vec3(x2, -y2, x2),
                new CANNON.Vec3(x2, y2, x2),
                new CANNON.Vec3(-x2, y2, x2)]
  var faces = [ [0, 5, 4],
                [0, 1, 5],
                [1, 0, 2],
                [3, 2, 0],
                [0, 4, 3],
                [1, 2, 5],
                [3, 4, 5],
                [3, 5, 2]]
  // return new CANNON.ConvexPolyhedron(verts, faces)
  return [verts, faces]
}

function createSlopeGeo(verts, faces){
  var slope = new THREE.Geometry()

  for(var i = 0; i < verts.length; i++){
    slope.vertices.push(new THREE.Vector3(verts[i].x, verts[i].y, verts[i].z))
  }

  for(var i = 0; i < faces.length; i++){
    slope.faces.push(new THREE.Face3(faces[i][0], faces[i][1], faces[i][2]))
  }
  slope.computeFaceNormals()

  return slope
}

function Bitmap(src, width, height) {
  this.image = new Image();
  this.image.src = src;
  this.width = width;
  this.height = height;
}

function init() {
  container = document.createElement('div')
  container.id = "container"
  document.body.appendChild(container);

  canvas = document.createElement('canvas')
  canvas.id = "canvas"
  container.appendChild(canvas)

  if(!overlay){
    overlay = createOverlay(canvas)
  }

  stats.showPanel( 0 ); // 0: fps, 1: ms, 2: mb, 3+: custom
  document.body.appendChild( stats.dom );

  camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x00bfff)
  var ambient = new THREE.AmbientLight( 0x404040, 0.5 );
  scene.add( ambient );

  var hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
  hemiLight.color.setHSL( 0.6, 1, 0.6 );
  hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
  hemiLight.position.set( 0, 500, 0 );
  scene.add( hemiLight );

  var dirLight = new THREE.DirectionalLight( 0xffffff, 0.8 );
  dirLight.position.set( -135, 146, 50 );
  dirLight.name = "dirlight";
  dirLight.target.position.set(0, 0, 0)

  // var shadowHelper = new THREE.CameraHelper( dirLight.shadow.camera );
  // scene.add(shadowHelper);

  var d = 200;
  dirLight.shadow.camera.left = -d;
  dirLight.shadow.camera.right = d;
  dirLight.shadow.camera.top = d;
  dirLight.shadow.camera.bottom = -d;
  scene.add( dirLight );

  dirLight.castShadow = true;
  dirLight.shadow.mapSize.width = dirLight.shadow.mapSize.height = 1024*2;
  dirLight.shadow.bias = -0.0007;

  // var helper = new THREE.DirectionalLightHelper( dirLight );
  // scene.add(helper);



  // Create a sphere
  var mass = 50, radius = 0.8, playerHeight = 2;
  // var size = new CANNON.Vec3(radius, radius, radius)
  // sphereShape = new CANNON.Sphere(radius)//new CANNON.Box(size)
  // sphereBody = new CANNON.Body({ mass: mass });


  var size = new CANNON.Vec3(radius/2, radius, radius/2)
  // var sphereShape = new CANNON.Box(size)// new CANNON.Sphere(radius)//
  var sphereShape = new CANNON.Sphere(radius)
  var sphereBody = new CANNON.Body({ mass: mass,
                               angularFactor: new CANNON.Vec3(0, 1, 0)
                             });

  sphereBody.addShape(sphereShape);
  sphereBody.position.set(0,3,0);
  sphereBody.linearDamping = 0.9;
  sphereBody.angularDamping = 0.5

  localPlayer = new RemotePlayer(sphereBody, null)

  controls = new PointerLockControls( camera , sphereBody );

  controls.oldPos = new THREE.Vector3().copy(controls.getObject().position)
  scene.add( controls.getObject() );

  // floor
  geometry = new THREE.PlaneGeometry( 300, 300, 50, 50 );
  geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );
  material = new THREE.MeshLambertMaterial( { color: 0xffffff } );
  mesh = new THREE.Mesh( geometry, material );
  mesh.receiveShadow = true;
  scene.add( mesh );


  raycaster = new THREE.Raycaster()

  renderer = new THREE.WebGLRenderer({canvas: canvas});
  renderer.shadowMap.enabled = true;
  renderer.shadowMapSoft = true;

  renderer.setSize( window.innerWidth, window.innerHeight );

  var axisHelper = new THREE.AxisHelper( 7 );
  scene.add( axisHelper );

  window.addEventListener( 'resize', onWindowResize, false );

  remotePlayers = [];

  socket = io.connect("http://sniper.satvik.co")
  setSocketEventHandlers()

}

function setSocketEventHandlers(){
  socket.on("connect", onSocketConnected);
  socket.on("disconnect", onSocketDisconnect);
  socket.on("new player", onNewPlayer);
  // socket.on("move player", onMovePlayer);
  socket.on("hit player", onHitPlayer);
  socket.on("remove player", onRemovePlayer);
  socket.on("mapData", onMapData);
  socket.on("updatePlayers", onUpdatePlayers);
}

function onMapData(data){
  worldSize = data.world.worldSize
  n = data.world.n
  tileWidth = data.world.tileWidth
  tileHeight = data.world.tileHeight
  boundaryHeight = data.world.boundaryHeight
  boundaryThickness = data.world.boundaryThickness
  boundaryWhitespace = data.world.boundaryWhitespace

  map = data.map

  initMap()
}

function onUpdatePlayers(data){
  var playerData = data.data
  for(var p = 0; p < playerData.length; p++){
    var id = playerData[p].id
    var position = playerData[p].position
    var quat = playerData[p].quat

    var player = playerById(id)

    if(!player && id != socket.id){
      return
    }

    if(socket.id == id){
      localPlayer.setPos(position)
      localPlayer.setQuat(quat)
    }else{
      player.setPos(position)
      player.setQuat(quat)
    }
  }
}


function createOverlay(mainCanvas){
  var canvasContainer = document.getElementById('container');
  var overlayCanvas = document.createElement('canvas');
  overlayCanvas.style.zIndex="1000";
  overlayCanvas.style.position = 'absolute';
  overlayCanvas.style.left = '0px';
  overlayCanvas.style.top = '0px';
  overlayCanvas.id = "overlay"
  overlayCanvas.width = mainCanvas.width;
  overlayCanvas.height = mainCanvas.height;

  weaponOverlay = document.createElement('canvas')
  weaponOverlay.id = "weaponOverlay"
  // weaponOverlay.width = window.innerWidth
  // weaponOverlay.height = window.innerHeight
  weaponOverlay.style.zIndex = "1001"
  weaponOverlay.style.position = 'absolute';
  weaponOverlay.style.right = '0px';
  weaponOverlay.style.bottom = '0px';


  weaponContext = weaponOverlay.getContext('2d')
  // weaponContext.imageSmoothingEnabled = false
  // weaponContext.transform(0.65,0.5,0,1,85,0);


  //scoping overlay
  scopingOverlay = document.createElement('canvas')
  scopingOverlay.style.zIndex="1002";//above weapon
  scopingOverlay.style.position = 'absolute';
  scopingOverlay.style.left = '0px';
  scopingOverlay.style.top = '0px';
  scopingOverlay.id = "scopingOverlay"
  scopingOverlay.width = window.innerWidth;
  scopingOverlay.height = window.innerHeight;
  scopingOverlay.style.display = 'none';

  scopingContext = scopingOverlay.getContext('2d')

  crosshairOverlay = document.createElement('canvas')
  crosshairOverlay.style.zIndex="2000";//above all else
  crosshairOverlay.style.position = 'absolute';
  crosshairOverlay.style.left = '0px';
  crosshairOverlay.style.top = '0px';
  crosshairOverlay.id = "crosshairOverlay"
  crosshairOverlay.width = window.innerWidth;
  crosshairOverlay.height = window.innerHeight;
  crosshairOverlay.style.display = 'none';

  crosshairContext = crosshairOverlay.getContext('2d')


  canvasContainer.appendChild(weaponOverlay)
  canvasContainer.appendChild(overlayCanvas);
  canvasContainer.appendChild(scopingOverlay);
  canvasContainer.appendChild(crosshairOverlay);
  return overlayCanvas;
}

// var innerWidth;
// var innerHeight;
var oldWidth = 0
var oldHeight = 0

function drawOverlay() {
  var context = overlay.getContext('2d');
  context.clearRect(0, 0, overlay.width, overlay.height);
  var x = 10;
  var y = 20;
  context.font = "12pt Calibri";
  context.fillStyle = "#0000ff"; // text color
  context.fillText("alpha v0.1", x, y);

  if(window.innerWidth != oldWidth || window.innerHeight != oldHeight){
    weaponOverlay.width = 0.234375 * window.innerWidth
    weaponOverlay.height = 0.1875 * window.innerHeight
    weaponContext.imageSmoothingEnabled = false
    weaponContext.transform(0.65,0.5,0,1,85,0);

    scopingOverlay.width = window.innerWidth
    scopingOverlay.height = window.innerHeight

    oldWidth = window.innerWidth
    oldHeight = window.innerHeight
  }

  weaponContext.clearRect(0, 0, weaponOverlay.width, weaponOverlay.height);
  var scale = new THREE.Vector2(weaponOverlay.width/weapon.width, weaponOverlay.height/weapon.height)
  var left = overlay.width * 0.66;
  var top = overlay.height * 0.6;
  weaponContext.drawImage(weapon.image, 0, 0, weapon.width*scale.x, weapon.height * scale.y);


  var scopingContextWidth = scopingOverlay.width
  var scopingContextHeight = scopingOverlay.height

  scopingContext.save()
  scopingContext.fillStyle = 'rgba(0, 0, 0, 1)';
  scopingContext.fillRect(0, 0, scopingContextWidth, scopingContextHeight)

  // Set global composite operation to destination-out
  scopingContext.globalCompositeOperation = 'destination-out';

  // Draw circle
  scopingContext.strokeStyle = "#FFFFFF";

  var centerX = scopingContextWidth/2, centerY = scopingContextHeight/2
  var radius = scopingContextHeight/5//((scopingContextWidth)/(scopingContextHeight))*75
  var crosshairadius = ((scopingContextWidth)/(scopingContextHeight))*10

  scopingContext.beginPath();
  scopingContext.arc(centerX, centerY, radius, 0, Math.PI*2, false);
  scopingContext.fill();

  crosshairOverlay.width = window.innerWidth
  crosshairOverlay.height = window.innerHeight

  var isScoping = controls.isScoping()
  crosshairContext.save()
  crosshairContext.clearRect(0, 0, crosshairOverlay.width, crosshairOverlay.height);//clearRect(centerX - radius, centerY - radius, centerX + radius, centerY + radius)
  crosshairContext.beginPath()
  if(isScoping == true){
    crosshairContext.moveTo(centerX - radius, centerY)
    crosshairContext.lineTo(centerX + radius, centerY)
    crosshairContext.moveTo(centerX, centerY - radius)
    crosshairContext.lineTo(centerX, centerY + radius)
    crosshairContext.stroke();
  }else if(isScoping == false){
    crosshairContext.moveTo(centerX - crosshairadius, centerY)
    crosshairContext.lineTo(centerX + crosshairadius, centerY)
    crosshairContext.moveTo(centerX, centerY - crosshairadius)
    crosshairContext.lineTo(centerX, centerY + crosshairadius)
    crosshairContext.stroke();
  }


  context.restore();
  weaponContext.restore();
  scopingContext.restore();
  crosshairContext.restore();
}

function onWindowResize(e) {
  // scopingOverlay.width = e.target.outerWidth
  // scopingOverlay.height = e.target.outerHeight
  // innerWidth = window.innerWidth
  // innerHeight = window.innerHeight

  console.log("resize "+window.innerWidth+" "+window.innerHeight)
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize( window.innerWidth, window.innerHeight );
}

function onSocketConnected() {
  console.log("Connected to socket server "+socket.id);
  var pos = controls.getPos()
  socket.emit("mapData")
  socket.emit("new player", {id: socket.id});
};

function onSocketDisconnect() {
  // console.log("Disconnected from socket server");
};

var mass = 50, radius = 0.8, playerHeight = 2;
// var ballGeometry = new THREE.BoxGeometry(radius, radius*2, radius);
var ballGeometry = new THREE.SphereGeometry(radius);

function onNewPlayer(data) {
  // console.log("New player connected: "+data.id);

  var size = new CANNON.Vec3(radius/2, radius, radius/2)
  // var bodyShape = new CANNON.Box(size)//new CANNON.Sphere(radius)
  var bodyShape = new CANNON.Sphere(radius)
  var body = new CANNON.Body({ mass: mass,
                               angularFactor: new CANNON.Vec3(0, 1, 0)
                             });
  body.linearDamping = 0.9;

  body.angularDamping = 0.5
  body.updateMassProperties();

  // var shape = new THREE.BoxGeometry(bodyShape.radius, 32, 32);
  var mesh = new THREE.Mesh( ballGeometry, material );

  var newPlayer = new RemotePlayer(body, mesh)
  newPlayer.id = data.id
  newPlayer.setPos(new CANNON.Vec3(data.x, data.y, data.z))

  newPlayer.getBody().addShape(bodyShape);
  addPhysicsBody(newPlayer.getBody());
  scene.add(newPlayer.getMesh())
  remotePlayers.push(newPlayer)
};

function onHitPlayer(data){
  var hitPlayer = playerById(data.id)

  if(!hitPlayer && socket.id != data.id){
    console.log("(hit) player not found: "+data.id)
  }

  if(socket.id == data.id){
    console.log("You've been hit!")
  }
}

function onRemovePlayer(data) {
  var removePlayer = playerById(data.id);

  if (!removePlayer) {
    console.log("Player not found: "+data.id);
    return;
  };

  scene.remove(removePlayer.getMesh())
  cw.world.remove(removePlayer.getBody())

  remotePlayers.splice(remotePlayers.indexOf(removePlayer), 1);
};

function playerById(id) {
  var i;
  for (i = 0; i < remotePlayers.length; i++) {
    if (remotePlayers[i].id == id)
    return remotePlayers[i];
  };

  return false;
};

function animate() {
  stats.begin()
  controls.update( Date.now() - time );

  var inputs = controls.inputs()
  // if(inputs.left || inputs.right || inputs.forward || inputs.backward || inputs.jump){
  socket.emit("move player", {id: socket.id, inputs: inputs});
  // }


  if(cannonDebugRenderer)
    // cannonDebugRenderer.update()

  renderer.render( scene, camera );
  drawOverlay()

  stats.end()
  time = Date.now();

  requestAnimationFrame( animate );
}

function getRemotePlayerObjects(){
  var objects = []
  for(var o = 0; o < remotePlayers.length; o++){
    objects.push(remotePlayers[o].getMesh())
  }
  return objects
}

function getRemotePlayerFromObject(obj){
  for(var o = 0; o < remotePlayers.length; o++){
    if(remotePlayers[o].getMesh() == obj){
      return remotePlayers[o]
    }
  }
  return false
}

//TODO Do hit test on server side
window.addEventListener("click",function(e){
  if(controls.enabled == true){
    raycaster.set(camera.getWorldPosition(), camera.getWorldDirection())
    var objects = getRemotePlayerObjects()
    var intersects = raycaster.intersectObjects(objects)

    if(intersects.length > 0){
      var shotPlayer = intersects[0].object
      var remotePlayer = getRemotePlayerFromObject(shotPlayer)
      console.log("Hit: "+remotePlayer.id)
      socket.emit("hit player", {id: remotePlayer.id});
    }
  }
});

</script>
</body>
</html>
